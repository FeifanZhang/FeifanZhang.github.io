{"pages":[{"title":"about","text":"推荐 在线图片压缩：wwei注册有上传图片大小要求时，可以大幅压缩，基本可以满足其要求 文件夹压缩：7zip支持windows系统，Linux系统移步至此，不支持MacOS系统 在线PDF处理：ILovePDF格式转换，合并分离皆可，Chrome浏览器有支持插件 (当然最好选择还是Adobe acrobat)，mac OS可以通过内置的预览来对PDF进行拆分，合并排序操作。 Markdown编辑：typora编辑响应快，所见即所得，可以选择与法偏好。","link":"/about/index.html"}],"posts":[{"title":"REST Framework reflaction","text":"当我们不知到类里有没有需要的属性以及方法时，通过反射来判断是否存在。 反射举例django处理HTTPresponse时，一般的写法如下所示: 12345678def view(request): if request.method == 'POST': ret = {'msg':'this is post method'} elif request.method == 'GET': ret = {'msg':'this is post method'} elif request.method == 'PUT': ret = {'msg':'this is post method'} return JsonResponse(ret) 首先通过request.method()判断请求方法，再根据不同的方法执行相应的语句。但是 REST framework中的APIView提供了一种机制：接收到request时，调用类中名称为request.method()的函数来执行： 12345678910111213141516171819202122232425262728293031class WordView(APIView): # add word def post(self, request, *args, **kwargs): try: ret = {\"words\": \"post\"} except Exception as e: ret = {\"error\": e.args} return JsonResponse(ret) # get word def get(self, request, *args, **kwargs): try: ret = {\"words\": \"get\"} except Exception as e: ret = {\"error\": e.args} return JsonResponse(ret) # delete word def delete(self, request, *args, **kwargs): try: ret = {\"words\": \"del\"} except Exception as e: ret = {\"error\": e.args} return JsonResponse(ret) def put(self, request, *args, **kwargs): try: ret = {\"words\": \"put\"} except Exception as e: ret = {\"error\": e.args} return JsonResponse(ret) APIView实现上述机制的原理（反射）:APIView会执行self.dispatch(): dispatch部分源码12345678910111213141516171819try: self.initial(request, *args, **kwargs) # Get the appropriate handler method # 判断request请求方法是否为HTTP规定的单词 # http_method_names = ['get', 'post', 'put', 'patch', 'delete', 'head', 'options', 'trace'] if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), # handler拿到函数名与请求方法名称一致的函数 self.http_method_not_allowed) # 如果没拿到，返回http_method_not_allowed 状态码为405 else: handler = self.http_method_not_allowed response = handler(request, *args, **kwargs)except Exception as exc: response = self.handle_exception(exc)self.response = self.finalize_response(request, response, *args, **kwargs)return self.response 从中也可以看出，APIView所支持的请求方法。","link":"/2020/03/13/REST-Framework-reflection/"},{"title":"Django cross-site","text":"CSRF保护跨站点请求伪造保护是一种防范特定类型攻击的机制，当用户尚未从网站注销并继续拥有有效会话时，就会发生这种攻击。在这种情况下，恶意站点可以在登录会话的上下文（cookies）对目标站点执行操作。 方法此类攻击，需要保证三件事： 安全的HTTP操作，不能用于更改任何服务器状态和数据，比如：GET, OPTIONS和HEAD 其余不安全的操作，则需要CSRF令牌。 除此之外，还要保证记录回话状态的数据（session，token等）的安全性（加密，设置存活时间）。Django中，csrf令牌的验证是在中间件内执行的，确切地说，是在中间件的process view中执行，因为中间件要判断路由对应的视图函数是否需要进行令牌验证（Django可通过装饰器局部注销验证） CSRF保护的流程如图所示： sequenceDiagram participant client participant server client->>server: 发送页面请求 server-->>client: 返回夹带csrf令牌的页面响应 client->>server: 发送夹带csrf的请求（包含token） server->>server: 验证令牌 alt csrf验证通过 server->>server: 验证token alt token验证通过 server->>server: 执行视图函数 server-->>client: 返回响应 else token验证未通过 server-->>client: 返回携带err的response end else csrf验证未通过 server-->>client: 返回携带err的response end 而跨站攻击就是在没有csrf令牌的保护下，hacker获取会话状态信息来生成对服务器数据或状态改变的http请求 sequenceDiagram participant client participant server participant hacker client->>server: 发送登录请求 server-->>client: 返回夹带token的响应 hacker->>client: 发送恶意链接 client->>hacker: 点击恶意链接后，hacker拿到你的token hacker->>server: 将获取的token加入请求，发送改变服务器数据的请求 server->>server: 验证通过，并执行相应的视图函数 跨站攻击，防御的核心是防止token被挟持可以通过令牌进行跨站攻击的防御 CORS一些部署在集群中的微服务，前后端是整体分离的，前端在和后端交互时，因为 ip+port必定不一样，所以就产生了跨站请求。 同源策略同源策略，即前后端的ip和端口号一致时，请求才能成功，不然会有跨站攻击的嫌疑，服务器会禁止这种请求，同源策略从一定程度上避免了跨站攻击，但是这样也影响了正常的前后端分离系统的交互。为了让前后端分离系统的交互能正常进行，则有了CORS。分为简单请求和复杂请求，浏览器会在请求头部自动添加信息，所以只需在服务器实现接口即可。 简单请求 方法为head，get，post。 头部不设置除此以外的字段：Accept，Accept-Language，Content-Language，Last-Event-ID，Content-Type（仅限于application/x-www-form-urlencoded、multipart/form-data、text/plain） 以上条件，缺一即为复杂请求 简单请求仅需要一次请求，在头部增加 Access-Control-Allow-Origin = '域名' 或 '*'字段即可 复杂请求 除简单请求以外的，皆为复杂请求 复杂请求会有两次请求：第一次为OPTIONS方法的预检请求，由于复杂请求时，首先会发送“预检”请求，如果“预检”成功，则发送真实数据。“预检”请求时，允许请求方式则需服务器设置响应头：Access-Control-Request-Method和Access-Control-Request-Headers Django CORS中间件的实现django-cors-headers GitHub官方文档 参考Ajax，CSRF&amp;CORS-Django REST框架Django中CSRF防御全过程解析以及中间件作用机制","link":"/2020/03/19/Django-cross-site/"},{"title":"Closure in python","text":"外函数的局部变量被内函数调取，当外函数执行完销毁时，被调用的变量会和内函数绑定避免销毁。 一：Python的闭包函数注意：var = func()是将func函数执行完的结果赋值给varvar = func是将func这个函数对象赋值给var 12345678910def outter_func(): fs = [] def inner_func(name): fs.append(name) print(fs) return inner_funcvar = outter_func()var('my') # print out ['my']var('name') # print out ['my','name'] outter_func按顺序执行 -&gt; 将inner_func函数对象作为结果返回给var -&gt; 返回后outter_func及其局部变量自动销毁，但fs被inner_func绑定，不会和outter_func一起销毁 -&gt; 成为inner_func私有变量 -&gt; 每次执行var('par')都会对fs造成累计改变。var中存放的，是由outter_func返回的inner_func对象，通过var('my')调用的是含有fs的inner_func('my')fs称为自由变量，可以用来记录闭包函数的每一次调用。外函数返回的对象为函数。 二：装饰器(语法糖)闭包函数中，返回值为对象这一特性的延伸。外函数的func参数会和func2进行绑定外函数的参数为函数对象，该对象在内函数中执行。不影响原有函数功能，可添加新功能。导入的第三方AIP无法重写时，可用装饰器进行修改。 1234567891011def func1(func): # 外函数的参数是被装饰函数对象 def func2(): print('this is func2') return func() # 返回的是函数func()的调用，即执行后的结果 return func2 # 返回的是函数对象@func1 def myprint(): print('hello')myprint() # 等同于 func1(myprint)() 函数myprint作为参数输入进func1中，且在内函数func2里被执行外函数func1返回的则是内函数对象。 三：带参数的装饰器在普通装饰器的基础上，增添一层函数来接收参数 1234567891011121314151617181920212223def func1(sex): def func2(func): # 内层和前面一样，在最外层嵌入一个`func1`来添加参数 def func3(): if sex == 'man': print('he is a man') if sex == 'woman': print('she is a woman') return func() return func3 return func2@func1(sex='man')def man(): print('human')@func1(sex='woman')def woman(): print('human')var1 = manvar2 = womanvar1() # he is a man humanvar2() # she is a human woman Django中，局部注销/添加 csrf token用到了带参数的装饰器。","link":"/2020/03/12/Closure-in-python/"},{"title":"REST Framework token","text":"HTTP协议是无状态协议，但是在用户操作时，需要通过用户的状态来进行不同的操作（比如登录与非登录的用户界面，功能不一样），token是解决这一问题的一种方法（还有session），其原理是在request中记录用户的状态（登录，未登录）。 一：token生成：基本流程如果通过用户信息验证，则生成一个token存储在response里，每一次访问server时，通过token确认是否是登录的用户。token的生成原理如下图所示 sequenceDiagram participant client participant server client->>server: 发送登录请求 server->>server: 验证用户信息 alt 验证通过 server->>server: 生成token server-->>client: 返回夹带token的response else 验证未通过 server-->>client: 返回携带err的response end 具体实现为了保证每一次登录生成的token都不一样，我选择将登录时间和用户名同时作为token参数 1234567def md5(username: str) -&gt; str: import hashlib # 局部引入md5加密算法 import time ctime = str(time.time()) # 生成时间戳 m = hashlib.md5(bytes(username, encoding='utf-8')) # username进行md5加密 m.update(bytes(ctime, encoding='utf-8')) # 加入时间戳加密 return m.hexdigest() 二：token原理：基本流程由于http协议自身无状态参数，通过token来记录当前用户的状态。可存放在cookie, body或是url（可能会有浏览器不支持或禁用cookie）。token的应用流程如下图所示： sequenceDiagram participant client participant server client->>server: 发送request server->>server: 验证request中的token alt 验证通过 server->>server: 执行相应的视图函数 server-->>client: 返回夹带token的response else 验证未通过 server-->>client: 返回携带err的response end 具体实现验证token时，加入对token的时间判断，如果和上一次访问时间差距过大（可能是非法攻击），则需要重新登录。 12345678910def confirm(self, *args, **kwargs): try: token = Token.objects.get(token=kwargs[\"token\"]) # token和user是一对一关系，所以用get if (timezone.now() - token.last_op_time).seconds &gt;= 30*60: # 判断距离上一次访问是否超过30分钟 raise exceptions.AuthenticationFailed(\"the token expired, login again\") else: token.save() # token里的时间属性带有auto_now字段，通过save可以激活时间属性自动更新时间 except Exception as e: raise exceptions.AuthenticationFailed(e.args) return token 三：通过REST Framework实现token认证REST Framework如何简化认证流程通常情况下，需要在每一个视图函数中都加入认证的方法，复杂项目中，某些视图函数会有多个认证，而有的函数则不需要。REST Framework给了我们管理这些认证的方法。在APIView源码中，有一个变量叫做authentication_classes的list变量： APIView部分源码1authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 而api_settings则是加载Django的setting文件中，REST Framework设置： api_settings部分源码123456api_settings = APISettings(None, DEFAULTS, IMPORT_STRINGS)def reload_api_settings(*args, **kwargs): setting = kwargs['setting'] if setting == 'REST_FRAMEWORK': api_settings.reload() Django settings文件内REST Framework的设置123REST_FRAMEWORK = { \"DEFAULT_AUTHENTICATION_CLASSES\": ['utils.auth.Authentication', ]} 所以authentication_classes是加载Django setting文件内设置的类。self.dispatch()-&gt; initialize_request()中的get_authenticators方法，会将authentication_classes里面的若干个类实例化去执行。所以在视图函数的类中，自定义authentication_classes来让REST Framework去初始化并执行需要的认证类。如果认证通过，则j执行视图函数，有问题则抛出异常。将认证类封装到同一个.py文件易于管理和调用。 Authentication类的实现1234567891011121314151617from loginapp import modelsfrom rest_framework import exceptionsfrom rest_framework.authentication import BaseAuthenticationclass Authentication(BaseAuthentication): def authenticate(self, request): token = request._request.GET.get('token') token_result = models.Token.objects.confirm(token=token) if not token_result: raise exceptions.AuthenticationFailed(\"user confirm failed\") else: return (token_result.user, token_result) def authenticate_header(self, request): pass BaseAuthentication是REST Framework的验证类，要实现认证必须继承它，并实现其中的authenticate和authenticate_header方法： BasicAuthentication源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class BasicAuthentication(BaseAuthentication): \"\"\" HTTP Basic authentication against username/password. \"\"\" www_authenticate_realm = 'api' # 此方法实现认证在子类必须重写的方法 def authenticate(self, request): \"\"\" Returns a `User` if a correct username and password have been supplied using HTTP Basic authentication. Otherwise returns `None`. \"\"\" auth = get_authorization_header(request).split() if not auth or auth[0].lower() != b'basic': return None if len(auth) == 1: msg = _('Invalid basic header. No credentials provided.') raise exceptions.AuthenticationFailed(msg) elif len(auth) &gt; 2: msg = _('Invalid basic header. Credentials string should not contain spaces.') raise exceptions.AuthenticationFailed(msg) try: auth_parts = base64.b64decode(auth[1]).decode(HTTP_HEADER_ENCODING).partition(':') except (TypeError, UnicodeDecodeError, binascii.Error): msg = _('Invalid basic header. Credentials not correctly base64 encoded.') raise exceptions.AuthenticationFailed(msg) userid, password = auth_parts[0], auth_parts[2] # 最后一步中，看出要返回的是一个元祖：(user,token)，并将其封装在request中 return self.authenticate_credentials(userid, password, request) def authenticate_credentials(self, userid, password, request=None): \"\"\" Authenticate the userid and password against username and password with optional request for context. \"\"\" credentials = { get_user_model().USERNAME_FIELD: userid, 'password': password } user = authenticate(request=request, **credentials) if user is None: raise exceptions.AuthenticationFailed(_('Invalid username/password.')) if not user.is_active: raise exceptions.AuthenticationFailed(_('User inactive or deleted.')) return (user, None) # 此方法实现认证在子类必须重写的方法（在方法内部直接写pass即可） def authenticate_header(self, request): return 'Basic realm=\"%s\"' % self.www_authenticate_realm 与BaseAuthentication同级的还有若干REST Framework封装好的验证类：TokenAuthentication，SessionAuthentication以及 BasicAuthentication，但是功能单一，不推荐使用。需要调用认证时在视图函数的类中直接初始化authentication_classes即可 调用认证12345# 在登录时，因为还没生成token所以局部取消认证，# 取消认证就是让 authentication_classes内部为空authentication_classes = []# 添加认证，就在authentication_classes内部添加即可authentication_classes = [Authentication]","link":"/2020/03/14/REST-Framework-token/"},{"title":"Python lambda expression","text":"lambda表达式可执行简单语句，多用于对list的处理。 lambda表达式 表达式参数lambda arg_list: expressionarg_lists是输入参数的形式，接受有的输入，比如: 12345a=1, 6*args**kargs[x, y]None expression则是简单的，单行语句，且需要的参数都在arg_lists中定义： 12341Nonea+b1 if a &gt; 0 else 2 表达式特性表达式有输入输出： 输入为arg_list，输出为expression的返回值函数匿名： lambda函数没有名称，不配拥有姓名功能有限： 其格式已经决定了只能用于简单的语句结构 应用场景将lambda函数赋值给变量，使得lambda函数拥有姓名12add = lambda x, y: x + yadd(1, 2) # 加法功能函数 输出为3 用lambda函数替换掉别的函数12time.sleep(3) #程序sleep三秒time.sleep = lambda x: print('HAHA') # 将sleep函数的内部替换为lambda函数，无论sleep的输入是多少，都会执行print('HAHA') lambda作为函数对象被返回给调用者闭包函数123456def outter(): fs = ['a', 'b', 'c'] return lambda x: fs.pop()a = outter()print(a(1)) # 输出cprint(a(1)) # 输出b lambda作为参数被python函数使用filter()此时lambda函数用于指定过滤列表元素的条件。例如filter(lambda x: x % 3 == 0, [1, 2, 3])指定将列表[1,2,3]中能够被3整除的元素过滤出来，其结果是[3] sorted()此时lambda函数用于指定对列表中所有元素进行排序的准则。例如sorted([1, 2, 3, 4, 5, 6, 7, 8, 9], key=lambda x: abs(5-x))将列表[1, 2, 3, 4, 5, 6, 7, 8, 9]按照元素与5距离从小到大进行排序，其结果是[5, 4, 6, 3, 7, 2, 8, 1, 9]。 map()此时lambda函数用于指定对列表中每一个元素的共同操作。例如map(lambda x: x+1, [1, 2,3])将列表[1, 2, 3]中的元素分别加1，其结果[2, 3, 4]。 reduce()：先对集合中第1，2个元素操作，得到的结果和第三个元素进行操作，以此类推此时lambda函数用于指定列表中两两相邻元素的结合条件。例如reduce(lambda a, b: ‘{}, {}’.format(a, b), [1, 2, 3, 4, 5, 6, 7, 8, 9])将列表 [1, 2, 3, 4, 5, 6, 7, 8, 9]中的元素从左往右两两以逗号分隔的字符的形式依次结合起来，其结果是’1, 2, 3, 4, 5, 6, 7, 8, 9’。 lambda表达式在递归的应用leetcode 第144题 1234def preorfer(root: TreeNode) -&gt; List[int]: # 前序写法，中序后序类似 p = lambda x: [x.val] + p(x.left) + p(x.right) if x else [] return p(root) 但是这种递归只能用于执行语句简单时，lambda不支持多分支，抛出异常等复杂语句。 参考团灭前中后序遍历的递归+迭代lambda完整讲解","link":"/2020/03/15/python-lambda-expression/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\" More info: Writing Run server123$ hexo server# shorthand as:$ hexo s More info: Server Generate static files123$ hexo generate# shorthand as:$ hexo g More info: Generating Deploy to remote sites123$ hexo deploy# shorthand as:$ hexo d 通过Netlify免费加速参考文章亲测有效通过Netlify免费加速 More info: Deployment","link":"/2020/03/15/hello-world/"},{"title":"Hexo UML diagram","text":"写博客时，需要添加UML图，但hexo的markdown不自带UML图渲染功能，所以通过安装hexo-filter-mermaid-diagrams插件来实现功能。 一：mermaid安装安装参考我的主题是icarus，没有after_foot.ejs文件，所以和hexo-filter-mermaid-diagrams的官方安装指南的step3有些差别，这里我除了官网的文档，还参考了一位和我使用同一主题的博主的配置方法，和他的唯一区别是我的icarus是最新版，他的老一些。要看他的博客可能需要“科（v）学（p）上（n）网”。 安装流程首先通过npm下载hexo-filter-mermaid-diagrams： 1npm i hexo-filter-mermaid-diagrams 其次在hexo根目录下的_config.yml文件的最后面加入如下配置： 123456# mermaid chartmermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: &quot;7.1.2&quot; # default v7.1.2 options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js #startOnload: true // default true 提示：如果需要类图，在_config.yml文件中设置external_link: false。最后，需要在自定义主题文件下添加代码，使用的主题不一样，添加的位置也不一样，使用icarus主题的可以参考本篇文章，我参考了前面说的这位博主；next主题网上很多可以搜到，其他主题移步官方文档查看。在\\themes\\icarus\\layout\\common\\footer.ejs中添加mermaid渲染： 123456789101112131415161718192021222324252627&lt;div class=&quot;level-end&quot;&gt;&lt;% if (Object.keys(links).length) { %&gt; &lt;div class=&quot;field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle&quot;&gt; &lt;% for (let name in links) { let link = links[name]; %&gt; &lt;p class=&quot;control&quot;&gt; &lt;a class=&quot;button is-white &lt;%= typeof(link) !== 'string' ? 'is-large' : '' %&gt;&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;&lt;%= name %&gt;&quot; href=&quot;&lt;%= url_for(typeof(link) === 'string' ? link : link.url) %&gt;&quot;&gt; &lt;% if (typeof(link) === 'string') { %&gt; &lt;%= name %&gt; &lt;% } else { %&gt; &lt;i class=&quot;&lt;%= link.icon %&gt;&quot;&gt;&lt;/i&gt; &lt;% } %&gt; &lt;/a&gt; &lt;/p&gt; &lt;% } %&gt; &lt;/div&gt;&lt;% } %&gt;//included mermaid&lt;% if (theme.mermaid.enable) { %&gt; &lt;script src='https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js'&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) { mermaid.initialize({theme: 'neutral'}); } &lt;/script&gt;&lt;% } %&gt;&lt;/div&gt; //included mermaid处为添加的代码。不要把//included mermaid复制进去，这个注释只是说明复制的位置和代码。如果复制了，页脚会把它也渲染进页面。 二：UML图语法画图没什么好说的，语法参考官方文档。如果画图语法错误，没有报错，只会在文章中空白显示，这里推荐一个在线mermaid编辑器检查语法，也可以将图转化为png或svg文件。网上的mermaid语法格式因为markdown编辑器不一而存在差异，本方法仅测试hexo下的可用性，其他种类的博客请酌情使用。","link":"/2020/03/15/hexo-UML-diagram/"}],"tags":[{"name":"django","slug":"django","link":"/tags/django/"},{"name":"restframework","slug":"restframework","link":"/tags/restframework/"},{"name":"reflection","slug":"reflection","link":"/tags/reflection/"},{"name":"csrf","slug":"csrf","link":"/tags/csrf/"},{"name":"cors","slug":"cors","link":"/tags/cors/"},{"name":"middleware","slug":"middleware","link":"/tags/middleware/"},{"name":"closure","slug":"closure","link":"/tags/closure/"},{"name":"decorator","slug":"decorator","link":"/tags/decorator/"},{"name":"token","slug":"token","link":"/tags/token/"},{"name":"lambda","slug":"lambda","link":"/tags/lambda/"},{"name":"recursion","slug":"recursion","link":"/tags/recursion/"},{"name":"binary tree","slug":"binary-tree","link":"/tags/binary-tree/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"mermaid","slug":"mermaid","link":"/tags/mermaid/"}],"categories":[{"name":"python","slug":"python","link":"/categories/python/"},{"name":"django","slug":"python/django","link":"/categories/python/django/"},{"name":"lambda","slug":"python/lambda","link":"/categories/python/lambda/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"closure","slug":"python/closure","link":"/categories/python/closure/"},{"name":"restframework","slug":"python/django/restframework","link":"/categories/python/django/restframework/"},{"name":"start","slug":"hexo/start","link":"/categories/hexo/start/"},{"name":"middleware","slug":"python/django/middleware","link":"/categories/python/django/middleware/"},{"name":"UML","slug":"hexo/UML","link":"/categories/hexo/UML/"}]}