{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"Vue学习笔记","text":"Vue学习笔记：vuex Vue学习笔记：vue-router Vue学习笔记：axios Vue学习笔记：hook","link":"/vuenote/index.html"},{"title":"工具推荐","text":"在线图片压缩：wwei 注册有上传图片大小要求时，可以大幅压缩到满足要求的程度 文件夹压缩：7zip支持windows系统，Linux系统移步至此，不支持MacOS系统 在线PDF处理：ILovePDF格式转换，合并分离皆可，Chrome浏览器有支持插件 (当然最好选择还是Adobe acrobat)，mac OS可以通过内置的预览来对PDF进行拆分，合并排序操作。 Markdown编辑：typora 编辑响应快，所见即所得，可以选择语法偏好。","link":"/toolRecommand/index.html"}],"posts":[{"title":"Closure in python","text":"外函数的局部变量被内函数调取，当外函数执行完销毁时，被调用的变量会和内函数绑定避免销毁。 一：Python的闭包函数注意：var = func()是将func函数执行完的结果赋值给varvar = func是将func这个函数对象赋值给var 12345678910def outter_func(): fs = [] def inner_func(name): fs.append(name) print(fs) return inner_funcvar = outter_func()var('my') # print out ['my']var('name') # print out ['my','name'] outter_func按顺序执行 -&gt; 将inner_func函数对象作为结果返回给var -&gt; 返回后outter_func及其局部变量自动销毁，但fs被inner_func绑定，不会和outter_func一起销毁 -&gt; 成为inner_func私有变量 -&gt; 每次执行var('par')都会对fs造成累计改变。var中存放的，是由outter_func返回的inner_func对象，通过var('my')调用的是含有fs的inner_func('my')fs称为自由变量，可以用来记录闭包函数的每一次调用。外函数返回的对象为函数。 二：装饰器(语法糖)闭包函数中，返回值为对象这一特性的延伸。外函数的func参数会和func2进行绑定外函数的参数为函数对象，该对象在内函数中执行。不影响原有函数功能，可添加新功能。导入的第三方AIP无法重写时，可用装饰器进行修改。 1234567891011def func1(func): # 外函数的参数是被装饰函数对象 def func2(): print('this is func2') return func() # 返回的是函数func()的调用，即执行后的结果 return func2 # 返回的是函数对象@func1 def myprint(): print('hello')myprint() # 等同于 func1(myprint)() 函数myprint作为参数输入进func1中，且在内函数func2里被执行外函数func1返回的则是内函数对象。 三：带参数的装饰器在普通装饰器的基础上，增添一层函数来接收参数 1234567891011121314151617181920212223def func1(sex): def func2(func): # 内层和前面一样，在最外层嵌入一个`func1`来添加参数 def func3(): if sex == 'man': print('he is a man') if sex == 'woman': print('she is a woman') return func() return func3 return func2@func1(sex='man')def man(): print('human')@func1(sex='woman')def woman(): print('human')var1 = manvar2 = womanvar1() # he is a man humanvar2() # she is a human woman Django中，局部注销/添加 csrf token用到了带参数的装饰器。","link":"/2020/03/12/Closure-in-python/"},{"title":"Django cross-site","text":"CSRF保护跨站点请求伪造保护是一种防范特定类型攻击的机制，当用户尚未从网站注销并继续拥有有效会话时，就会发生这种攻击。在这种情况下，恶意站点可以在登录会话的上下文（cookies）对目标站点执行操作。 方法此类攻击，需要保证三件事： 安全的HTTP操作，不能用于更改任何服务器状态和数据，比如：GET, OPTIONS和HEAD 其余不安全的操作，则需要CSRF令牌。 除此之外，还要保证记录回话状态的数据（session，token等）的安全性（加密，设置存活时间）。Django中，csrf令牌的验证是在中间件内执行的，确切地说，是在中间件的process view中执行，因为中间件要判断路由对应的视图函数是否需要进行令牌验证（Django可通过装饰器局部注销验证） CSRF保护的流程如图所示： sequenceDiagram participant client participant server client->>server: 发送页面请求 server-->>client: 返回夹带csrf令牌的页面响应 client->>server: 发送夹带csrf的请求（包含token） server->>server: 验证令牌 alt csrf验证通过 server->>server: 验证token alt token验证通过 server->>server: 执行视图函数 server-->>client: 返回响应 else token验证未通过 server-->>client: 返回携带err的response end else csrf验证未通过 server-->>client: 返回携带err的response end 而跨站攻击就是在没有csrf令牌的保护下，hacker获取会话状态信息来生成对服务器数据或状态改变的http请求 sequenceDiagram participant client participant server participant hacker client->>server: 发送登录请求 server-->>client: 返回夹带token的响应 hacker->>client: 发送恶意链接 client->>hacker: 点击恶意链接后，hacker拿到你的token hacker->>server: 将获取的token加入请求，发送改变服务器数据的请求 server->>server: 验证通过，并执行相应的视图函数 跨站攻击，防御的核心是防止token被挟持可以通过令牌进行跨站攻击的防御 CORS一些部署在集群中的微服务，前后端是整体分离的，前端在和后端交互时，因为 ip+port必定不一样，所以就产生了跨站请求。 同源策略同源策略，即前后端的ip和端口号一致时，请求才能成功，不然会有跨站攻击的嫌疑，服务器会禁止这种请求，同源策略从一定程度上避免了跨站攻击，但是这样也影响了正常的前后端分离系统的交互。为了让前后端分离系统的交互能正常进行，则有了CORS。分为简单请求和复杂请求，浏览器会在请求头部自动添加信息，所以只需在服务器实现接口即可。 简单请求 方法为head，get，post。 头部不设置除此以外的字段：Accept，Accept-Language，Content-Language，Last-Event-ID，Content-Type（仅限于application/x-www-form-urlencoded、multipart/form-data、text/plain） 以上条件，缺一即为复杂请求 简单请求仅需要一次请求，在头部增加 Access-Control-Allow-Origin = '域名' 或 '*'字段即可 复杂请求 除简单请求以外的，皆为复杂请求 复杂请求会有两次请求：第一次为OPTIONS方法的预检请求，由于复杂请求时，首先会发送“预检”请求，如果“预检”成功，则发送真实数据。“预检”请求时，允许请求方式则需服务器设置响应头：Access-Control-Request-Method和Access-Control-Request-Headers Django CORS中间件的实现django-cors-headers GitHub官方文档 参考Ajax，CSRF&amp;CORS-Django REST框架Django中CSRF防御全过程解析以及中间件作用机制","link":"/2020/03/19/Django-cross-site/"},{"title":"Vue笔记：vue-router","text":"vue-router简介vue-router的功能是通过前端路由来调取对应的插件，和后端的url路由类似（后端是通过路由执行对应视图函数）， vue-router基础使用 npm install vue-router --save安装 如果创建vue app时，选择了vue-router，在src/router目录有一个有index.js 文件,内部搭好了router结构，直接按下面代码创建路由列表即可，如果创建vue app时，没选择加载vue-router 则按如下方法创建:在项目根目录下创建 router.js 并在里面添加如下代码123456789101112131415161718192021222324252627282930313233343536import Vue from 'vue'import VueRouter from 'vue-router'// 以下是要添加路由的组件import Nav from './components/homeComponents/Nav.vue'import Login from './components/Login.vue'// 将vue-router安装至vue中Vue.use(VueRouter);// 创建路由列表const routes=[ //单个路由均为对象类型，path代表的是路径，component代表组件 //处理特殊情况的代码（例如重定向）写在最前面 { // 如果输入的path为空 则重定向到'/login' path:'', redirect:'login' }, { // path是和组件绑定的路径（不要写成url） path:'/homepage', component:Nav }, { path:'/login', component:Login },];//实例化VueRouter并将routes添加进去const router=new VueRouter({//ES6简写，等于routes：routes routes});//抛出这个这个实例对象方便外部读取以及访问export default router 在main.js中。作如下修改：123456789101112131415// 在main.js文件开头进行如下设置：// 将vuex注册进入vue内Vue.use(Vuex);// 引入 router.js文件，下一步在文件的结尾处挂载import router from './router.js'Vue.config.productionTip = false;// 在文件结尾的new Vue处，挂载引入的router文件new Vue({ render: h =&gt; h(App), // 将router挂载进app.vue router, // 添加history模式，使得加载的url为html模式（刷新不会出现xxx/#/login的情况） mode: 'history'}).$mount('#app'); 在 App.vue的中，加入以下代码：12345678910111213&lt;template&gt; &lt;div id=\"app\"&gt; /*router-link在浏览器会被渲染为a标签*/ /*router-link内，to后面的path则是a标签的链接*/ /*不想将router-link渲染为a标签，增加tag属性转换为其他标签*/ /*点击login和homepage两个button后，发现可以通过浏览器的后退返回到点击之前的页面状态，在单页面应用是不允许的，设置replace阻止返回*/ /*replace的原理在下一章节 vue-router路由跳转解释*/ &lt;router-link to=\"/login\" tag=\"button\" replace&gt;login&lt;/router-link&gt; &lt;router-link to=\"/homepage\" tag=\"button\" replace&gt;homepage&lt;/router-link&gt; /*router-view接收每个router-link对应path的组件并显示*/ &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 使用history模式时，会出现用户在未登录的情况下，直接访问登录后的功能或页面，在后台要有机制去处理未授权的请求，前端axios也要注意从后台catch错误时，要如何处理（强行访问未授权的部分，应当是返回登录界面） router-link的用法解析 router-link标签会渲染成a标签，通过tag来将其转化为其他标签，转换完，可添加class方便其进行渲染12/*前端会渲染其成为class为submit的button*/&lt;router-link to=\"/login\" tag=\"button\" class=\"submit\" replace&gt;login&lt;/router-link&gt; vue-router路由跳转路由跳转，有两种实现：第一种是replace, 即路由跳转后，无法退回之前的状态（浏览器无法使用后退键），第二种就是push实现，即可以退回历史状态在vue组件内如下实现12345//路由必须是配置过的路由（参考文章前一部分）// 跳转到不同的url，但这个方法会向history栈添加一个记录，点击后退会返回到上一个页面。this.$router.push('/homepage');// 同样是跳转到指定的url，但是这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。this.$router.replace('/homepage'); 路由传参动态路由（params传参）类似http请求的RESTful样式（www.a.com/product/1 和 www.a.com/product/2 调用的是同一视图函数 将对应编号的product数据返回给前端）以下是设置动态路由在router.js的路由列表中如下设置1234567891011121314151617const routes=[ //单个路由均为对象类型，path代表的是路径，component代表组件 //特殊情况的代码写在最开始， { path:'', redirect:'login' }, { //路由中 /:token即为动态的部分 path:'/homepage/:token', component:Nav }, { path:'/login', component:Login },]; 在vue组件中要跳转的部分添加如下代码12//将axios中返回响应体内的token和path做拼接this.$router.replace(\"/homepage/\"+res.data.token); 设置完成后，在被路由调用的组件内，拿到动态路由所传的值在被调用的组件内加入12345678computed:{ token(){ // $route所拿到的路由是目前正活跃的路由 // $router是获取路由列表内所有的路由 // params.后面跟的参数要和router.js 设置的路由参数一样 return this.$route.params.token }}, query传参当有路由嵌套时，无法通过params传参，此时要query传参。在router.js中配置路由常规配置即可1234{ path:'/homepage', component:() =&gt; import('./components/homeComponents/Nav.vue')}, 在组件的文件内加入以下代码12//replace内传递的为对象：向路径为 /homepage的组件传递 token为res.data.token内的值this.$router.replace({path: '/homepage', query: {token: res.data.token}}) 在接收参数的组件内加入this.$query.token来接受参数1234567computed:{ token(){ // $route所拿到的路由是目前正活跃的路由 // $router是获取路由列表内所有的路由 return this.$route.query.token }}, 懒加载（按需加载）vue的所有路由下的组件会打包在一个js文件中，当主页面加载时，其余页面也会同时加载。如果项目组件数量巨大，同时加载速度很慢，其中有些x组件需要及时加载（首页，新闻，产品推送），有些则不需要（设置，账户管理这些首页默认不会显示），设置懒加载项目打包时会分在不同js文件下，用户在使用组件时才会加载。 在router.js的路由列表中如下设置1234567891011121314151617const routes=[ //单个路由均为对象类型，path代表的是路径，component代表组件 //特殊情况的代码写在最开始，如果写在最后，后期可能会在后面加代码，特殊情况的代码就难找到了 { path:'', redirect:'login' }, { //路由中 /:token即为动态的部分 path:'/homepage/:token', component:() =&gt; import('./components/homeComponents/Nav.vue') }, { path:'/login', component:() =&gt; import('./components/Login.vue') },]; 路由的嵌套路由的嵌套类似于后台路由的二次分配，在前端，有一个组件A 其路由为 /A, 他有两个子组件为A1和A2， 子组件的路由应为 /A/A1 和 /A/A2, 如何分配路径，就是路由的嵌套。 在router.js中配置路由1234567891011121314151617181920212223242526const routes=[ { path:'/homepage', component:() =&gt; import('./components/homeComponents/Nav.vue'), //在父子件下加入children为关键字的子路由列表（懒加载形式） children:[ { path: 'anniversary', component:() =&gt; import('./components/homeComponents/Anniversary.vue') }, { path: 'clock', component:() =&gt; import('./components/homeComponents/Clock.vue') }, { path: 'photos', component: () =&gt; import('./components/homeComponents/Photos.vue') }, { path: 'words', component: () =&gt; import('./components/homeComponents/Words.vue') }, ] },]; 在vue的模板内这样调用12345678&lt;div class=\"NavButtons\"&gt; &lt;h1&gt;HomePage&lt;/h1&gt; &lt;div&gt;&lt;router-link to=\"/homepage/photos\" tag=\"button\" class=\"submit\" replace&gt;照 片&lt;/router-link&gt;&lt;/div&gt; &lt;div&gt;&lt;router-link to=\"/homepage/anniversary\" tag=\"button\" class=\"submit\" replace&gt;纪念日&lt;/router-link&gt;&lt;/div&gt; &lt;div&gt;&lt;router-link to=\"/homepage/clock\" tag=\"button\" class=\"submit\" replace&gt;计 时&lt;/router-link&gt;&lt;/div&gt; &lt;div&gt;&lt;router-link to=\"/homepage/words\" tag=\"button\" class=\"submit\" replace&gt;想说的话&lt;/router-link&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=\"button\" name=\"\" value=\"返 回\" @click=\"returnToLogin\"/&gt;&lt;/div&gt;&lt;/div&gt; 路由导航守卫路由跳转或在路由跳转时执行一些函数（类似于钩子函数），通过全局的路由导航守卫来监听并且执行。 遇到的问题 [Vue warn]: Unknown custom element: - did you register the component correctly? For recursive components, make sure to provide the “name” option.router-link 的tag不能使用submit要用button参考Vue路由（vue-router）详细讲解指南vue-router中文文档vue-router的push和replace的区别","link":"/2020/03/24/Vuenote-vue-router/"},{"title":"REST Framework reflaction","text":"当我们不知到类里有没有需要的属性以及方法时，通过反射来判断是否存在。 反射举例django处理HTTPresponse时，一般的写法如下所示: 12345678def view(request): if request.method == 'POST': ret = {'msg':'this is post method'} elif request.method == 'GET': ret = {'msg':'this is post method'} elif request.method == 'PUT': ret = {'msg':'this is post method'} return JsonResponse(ret) 首先通过request.method()判断请求方法，再根据不同的方法执行相应的语句。但是 REST framework中的APIView提供了一种机制：接收到request时，调用类中名称为request.method()的函数来执行： 12345678910111213141516171819202122232425262728293031class WordView(APIView): # add word def post(self, request, *args, **kwargs): try: ret = {\"words\": \"post\"} except Exception as e: ret = {\"error\": e.args} return JsonResponse(ret) # get word def get(self, request, *args, **kwargs): try: ret = {\"words\": \"get\"} except Exception as e: ret = {\"error\": e.args} return JsonResponse(ret) # delete word def delete(self, request, *args, **kwargs): try: ret = {\"words\": \"del\"} except Exception as e: ret = {\"error\": e.args} return JsonResponse(ret) def put(self, request, *args, **kwargs): try: ret = {\"words\": \"put\"} except Exception as e: ret = {\"error\": e.args} return JsonResponse(ret) APIView实现上述机制的原理（反射）:APIView会执行self.dispatch(): dispatch部分源码12345678910111213141516171819try: self.initial(request, *args, **kwargs) # Get the appropriate handler method # 判断request请求方法是否为HTTP规定的单词 # http_method_names = ['get', 'post', 'put', 'patch', 'delete', 'head', 'options', 'trace'] if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), # handler拿到函数名与请求方法名称一致的函数 self.http_method_not_allowed) # 如果没拿到，返回http_method_not_allowed 状态码为405 else: handler = self.http_method_not_allowed response = handler(request, *args, **kwargs)except Exception as exc: response = self.handle_exception(exc)self.response = self.finalize_response(request, response, *args, **kwargs)return self.response 从中也可以看出，APIView所支持的请求方法。","link":"/2020/03/13/REST-Framework-reflection/"},{"title":"REST Framework token","text":"HTTP协议是无状态协议，但是在用户操作时，需要通过用户的状态来进行不同的操作（比如登录与非登录的用户界面，功能不一样），token是解决这一问题的一种方法（还有session），其原理是在request中记录用户的状态（登录，未登录）。 一：token生成：基本流程如果通过用户信息验证，则生成一个token存储在response里，每一次访问server时，通过token确认是否是登录的用户。token的生成原理如下图所示 sequenceDiagram participant client participant server client->>server: 发送登录请求 server->>server: 验证用户信息 alt 验证通过 server->>server: 生成token server-->>client: 返回夹带token的response else 验证未通过 server-->>client: 返回携带err的response end 具体实现为了保证每一次登录生成的token都不一样，我选择将登录时间和用户名同时作为token参数 1234567def md5(username: str) -&gt; str: import hashlib # 局部引入md5加密算法 import time ctime = str(time.time()) # 生成时间戳 m = hashlib.md5(bytes(username, encoding='utf-8')) # username进行md5加密 m.update(bytes(ctime, encoding='utf-8')) # 加入时间戳加密 return m.hexdigest() 二：token原理：基本流程由于http协议自身无状态参数，通过token来记录当前用户的状态。可存放在cookie, body或是url（可能会有浏览器不支持或禁用cookie）。token的应用流程如下图所示： sequenceDiagram participant client participant server client->>server: 发送request server->>server: 验证request中的token alt 验证通过 server->>server: 执行相应的视图函数 server-->>client: 返回夹带token的response else 验证未通过 server-->>client: 返回携带err的response end 具体实现验证token时，加入对token的时间判断，如果和上一次访问时间差距过大（可能是非法攻击），则需要重新登录。 12345678910def confirm(self, *args, **kwargs): try: token = Token.objects.get(token=kwargs[\"token\"]) # token和user是一对一关系，所以用get if (timezone.now() - token.last_op_time).seconds &gt;= 30*60: # 判断距离上一次访问是否超过30分钟 raise exceptions.AuthenticationFailed(\"the token expired, login again\") else: token.save() # token里的时间属性带有auto_now字段，通过save可以激活时间属性自动更新时间 except Exception as e: raise exceptions.AuthenticationFailed(e.args) return token 三：通过REST Framework实现token认证REST Framework如何简化认证流程通常情况下，需要在每一个视图函数中都加入认证的方法，复杂项目中，某些视图函数会有多个认证，而有的函数则不需要。REST Framework给了我们管理这些认证的方法。在APIView源码中，有一个变量叫做authentication_classes的list变量： APIView部分源码1authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 而api_settings则是加载Django的setting文件中，REST Framework设置： api_settings部分源码123456api_settings = APISettings(None, DEFAULTS, IMPORT_STRINGS)def reload_api_settings(*args, **kwargs): setting = kwargs['setting'] if setting == 'REST_FRAMEWORK': api_settings.reload() Django settings文件内REST Framework的设置123REST_FRAMEWORK = { \"DEFAULT_AUTHENTICATION_CLASSES\": ['utils.auth.Authentication', ]} 所以authentication_classes是加载Django setting文件内设置的类。self.dispatch()-&gt; initialize_request()中的get_authenticators方法，会将authentication_classes里面的若干个类实例化去执行。所以在视图函数的类中，自定义authentication_classes来让REST Framework去初始化并执行需要的认证类。如果认证通过，则j执行视图函数，有问题则抛出异常。将认证类封装到同一个.py文件易于管理和调用。 Authentication类的实现1234567891011121314151617from loginapp import modelsfrom rest_framework import exceptionsfrom rest_framework.authentication import BaseAuthenticationclass Authentication(BaseAuthentication): def authenticate(self, request): token = request._request.GET.get('token') token_result = models.Token.objects.confirm(token=token) if not token_result: raise exceptions.AuthenticationFailed(\"user confirm failed\") else: return (token_result.user, token_result) def authenticate_header(self, request): pass BaseAuthentication是REST Framework的验证类，要实现认证必须继承它，并实现其中的authenticate和authenticate_header方法： BasicAuthentication源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class BasicAuthentication(BaseAuthentication): \"\"\" HTTP Basic authentication against username/password. \"\"\" www_authenticate_realm = 'api' # 此方法实现认证在子类必须重写的方法 def authenticate(self, request): \"\"\" Returns a `User` if a correct username and password have been supplied using HTTP Basic authentication. Otherwise returns `None`. \"\"\" auth = get_authorization_header(request).split() if not auth or auth[0].lower() != b'basic': return None if len(auth) == 1: msg = _('Invalid basic header. No credentials provided.') raise exceptions.AuthenticationFailed(msg) elif len(auth) &gt; 2: msg = _('Invalid basic header. Credentials string should not contain spaces.') raise exceptions.AuthenticationFailed(msg) try: auth_parts = base64.b64decode(auth[1]).decode(HTTP_HEADER_ENCODING).partition(':') except (TypeError, UnicodeDecodeError, binascii.Error): msg = _('Invalid basic header. Credentials not correctly base64 encoded.') raise exceptions.AuthenticationFailed(msg) userid, password = auth_parts[0], auth_parts[2] # 最后一步中，看出要返回的是一个元祖：(user,token)，并将其封装在request中 return self.authenticate_credentials(userid, password, request) def authenticate_credentials(self, userid, password, request=None): \"\"\" Authenticate the userid and password against username and password with optional request for context. \"\"\" credentials = { get_user_model().USERNAME_FIELD: userid, 'password': password } user = authenticate(request=request, **credentials) if user is None: raise exceptions.AuthenticationFailed(_('Invalid username/password.')) if not user.is_active: raise exceptions.AuthenticationFailed(_('User inactive or deleted.')) return (user, None) # 此方法实现认证在子类必须重写的方法（在方法内部直接写pass即可） def authenticate_header(self, request): return 'Basic realm=\"%s\"' % self.www_authenticate_realm 与BaseAuthentication同级的还有若干REST Framework封装好的验证类：TokenAuthentication，SessionAuthentication以及 BasicAuthentication，但是功能单一，不推荐使用。需要调用认证时在视图函数的类中直接初始化authentication_classes即可 调用认证12345# 在登录时，因为还没生成token所以局部取消认证，# 取消认证就是让 authentication_classes内部为空authentication_classes = []# 添加认证，就在authentication_classes内部添加即可authentication_classes = [Authentication]","link":"/2020/03/14/REST-Framework-token/"},{"title":"Vue笔记：vue-router","text":"vue组件生命周期简介vue 钩子函数computed创建vue组件时调用 mountedvue组件的模板挂载到DOM上时调用 updated数据刷新时调用 method参考","link":"/2020/03/24/Vuenote-hook/"},{"title":"Vue笔记：axios","text":"vuex简介axios基础使用axios全局配置main.js不能用use配置 Uncaught (in promise) TypeError: Cannot read property ‘protocol’ of undefined 参考","link":"/2020/03/24/Vuenote-axios/"},{"title":"Vue笔记：vuex","text":"vuex简介Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。比如：兄弟组件之间共用同一个参数来调整自己的状态，传参的方法对于多层嵌套的组件将会非常繁琐。跨组件传参，有全局变量时，使用vuex传参。 vuex使用 首先通过npm install vuex来安装vuex 在main.vue中，作如下声明：1234567891011121314151617181920212223242526272829303132333435363738394041424344// 首先&lt;script&gt;下导入vueximport Vuex from 'vuex'// 将vuex安装进vueVue.use(Vuex);const store = new Vuex.Store({ // state用来声明变量并初始化 state:{ pageStatus: 0, token: \"\" }, // state内的变量不能直接修改，通过调取mutations内的方法进行修改 // mutation内实现了三个方法：pageStatus的加，减以及字符串token的赋值 mutations:{ // 将pageStatus变量 +1 increase(state){ state.pageStatus += 1; }, // 将pageStatus变量 +1 decrease(state){ state.pageStatus -= 1; }, // 将token赋值，注意要声明输入的参数str set_token(state, str){ state.token = str } }, // state内的变量不能直接获取，要通过getters方法声明 getters:{ // 获取 token get_token(state){ return state.token } }, actions:{ }});new Vue({ render: h =&gt; h(App), router, // 将store挂载进app.vue store}).$mount('#app'); 在自定义的组件内，声明如下：首先在computed获取变量,在methed获取变量对应的get set方法12345678910111213141516171819//在 &lt;script&gt; 标签下导入import {mapState} from 'vuex';//在 &lt;script&gt; 下的computed获取全局变量，method中获取get set方法：computed:{ // 获取全局变量 ...mapState(['pageStatus', \"token\"])},methed:{ // 获取全局变量所对应的get set方法 ...mapState([\"increase\", \"decrease\", \"set_token\"]), returnToLogin:function(){ // 通过调用 main.js的mutations中decrease方法，使得 pageStatus -= 1 this.$store.commit('decrease'); // 通过 increase方法来改变token的值（即 global token = this.token） this.$store.commit('set_token', this.token); this.toClock();} 通过上述方法后，变量可以在vue的模板内进行调用vue组件的模板内1&lt;div v-show=\"pageStatus == 0\"&gt;&lt;/div&gt; 遇到的异常[Vue warn]: The computed property “token” is already defined in data.组件中data声明的变量名称与vuex 中设置的全局变量一样导致报错，即vuex中有名为token的变量，组件的data中也声明了名为token的变量，解决方法：重新命名组件内的变量。 参考","link":"/2020/03/24/Vuenote-vuex/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.官方文档中文版请移步至此 Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server123$ hexo server# shorthand as:$ hexo s More info: Server Generate static files123$ hexo generate# shorthand as:$ hexo g More info: Generating Deploy to remote sites123$ hexo deploy# shorthand as:$ hexo d 通过Netlify免费加速参考文章亲测有效通过Netlify免费加速 More info: Deployment","link":"/2020/03/15/hello-world/"},{"title":"Hexo UML diagram","text":"写博客时，需要添加UML图，但hexo的markdown不自带UML图渲染功能，所以通过安装hexo-filter-mermaid-diagrams插件来实现功能。 一：mermaid安装安装参考我的主题是icarus，没有after_foot.ejs文件，所以和hexo-filter-mermaid-diagrams的官方安装指南的step3有些差别，这里我除了官网的文档，还参考了一位和我使用同一主题的博主的配置方法，和他的唯一区别是我的icarus是最新版，他的老一些。要看他的博客可能需要“科（v）学（p）上（n）网”。 安装流程首先通过npm下载hexo-filter-mermaid-diagrams： 1npm i hexo-filter-mermaid-diagrams 其次在hexo根目录下的_config.yml文件的最后面加入如下配置： 123456# mermaid chartmermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: &quot;7.1.2&quot; # default v7.1.2 options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js #startOnload: true // default true 提示：如果需要类图，在_config.yml文件中设置external_link: false。最后，需要在自定义主题文件下添加代码，使用的主题不一样，添加的位置也不一样，使用icarus主题的可以参考本篇文章，我参考了前面说的这位博主；next主题网上很多可以搜到，其他主题移步官方文档查看。在\\themes\\icarus\\layout\\common\\footer.ejs中添加mermaid渲染： 123456789101112131415161718192021222324252627&lt;div class=&quot;level-end&quot;&gt;&lt;% if (Object.keys(links).length) { %&gt; &lt;div class=&quot;field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle&quot;&gt; &lt;% for (let name in links) { let link = links[name]; %&gt; &lt;p class=&quot;control&quot;&gt; &lt;a class=&quot;button is-white &lt;%= typeof(link) !== 'string' ? 'is-large' : '' %&gt;&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;&lt;%= name %&gt;&quot; href=&quot;&lt;%= url_for(typeof(link) === 'string' ? link : link.url) %&gt;&quot;&gt; &lt;% if (typeof(link) === 'string') { %&gt; &lt;%= name %&gt; &lt;% } else { %&gt; &lt;i class=&quot;&lt;%= link.icon %&gt;&quot;&gt;&lt;/i&gt; &lt;% } %&gt; &lt;/a&gt; &lt;/p&gt; &lt;% } %&gt; &lt;/div&gt;&lt;% } %&gt;//included mermaid&lt;% if (theme.mermaid.enable) { %&gt; &lt;script src='https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js'&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) { mermaid.initialize({theme: 'neutral'}); } &lt;/script&gt;&lt;% } %&gt;&lt;/div&gt; //included mermaid处为添加的代码。不要把//included mermaid复制进去，这个注释只是说明复制的位置和代码。如果复制了，页脚会把它也渲染进页面。 二：UML图语法画图没什么好说的，语法参考官方文档。如果画图语法错误，没有报错，只会在文章中空白显示，这里推荐一个在线mermaid编辑器检查语法，也可以将图转化为png或svg文件。网上的mermaid语法格式因为markdown编辑器不一而存在差异，本方法仅测试hexo下的可用性，其他种类的博客请酌情使用。","link":"/2020/03/15/hexo-UML-diagram/"},{"title":"Python lambda expression","text":"lambda表达式可执行简单语句，多用于对list的处理。 lambda表达式 表达式参数lambda arg_list: expressionarg_lists是输入参数的形式，接受有的输入，比如: 12345a=1, 6*args**kargs[x, y]None expression则是简单的，单行语句，且需要的参数都在arg_lists中定义： 12341Nonea+b1 if a &gt; 0 else 2 表达式特性表达式有输入输出： 输入为arg_list，输出为expression的返回值函数匿名： lambda函数没有名称，不配拥有姓名功能有限： 其格式已经决定了只能用于简单的语句结构 应用场景将lambda函数赋值给变量，使得lambda函数拥有姓名12add = lambda x, y: x + yadd(1, 2) # 加法功能函数 输出为3 用lambda函数替换掉别的函数12time.sleep(3) #程序sleep三秒time.sleep = lambda x: print('HAHA') # 将sleep函数的内部替换为lambda函数，无论sleep的输入是多少，都会执行print('HAHA') lambda作为函数对象被返回给调用者闭包函数123456def outter(): fs = ['a', 'b', 'c'] return lambda x: fs.pop()a = outter()print(a(1)) # 输出cprint(a(1)) # 输出b lambda作为参数被python函数使用filter()此时lambda函数用于指定过滤列表元素的条件。例如filter(lambda x: x % 3 == 0, [1, 2, 3])指定将列表[1,2,3]中能够被3整除的元素过滤出来，其结果是[3] sorted()此时lambda函数用于指定对列表中所有元素进行排序的准则。例如sorted([1, 2, 3, 4, 5, 6, 7, 8, 9], key=lambda x: abs(5-x))将列表[1, 2, 3, 4, 5, 6, 7, 8, 9]按照元素与5距离从小到大进行排序，其结果是[5, 4, 6, 3, 7, 2, 8, 1, 9]。 map()此时lambda函数用于指定对列表中每一个元素的共同操作。例如map(lambda x: x+1, [1, 2,3])将列表[1, 2, 3]中的元素分别加1，其结果[2, 3, 4]。 reduce()：先对集合中第1，2个元素操作，得到的结果和第三个元素进行操作，以此类推此时lambda函数用于指定列表中两两相邻元素的结合条件。例如reduce(lambda a, b: ‘{}, {}’.format(a, b), [1, 2, 3, 4, 5, 6, 7, 8, 9])将列表 [1, 2, 3, 4, 5, 6, 7, 8, 9]中的元素从左往右两两以逗号分隔的字符的形式依次结合起来，其结果是’1, 2, 3, 4, 5, 6, 7, 8, 9’。 lambda表达式在递归的应用leetcode 第144题 1234def preorfer(root: TreeNode) -&gt; List[int]: # 前序写法，中序后序类似 p = lambda x: [x.val] + p(x.left) + p(x.right) if x else [] return p(root) 但是这种递归只能用于执行语句简单时，lambda不支持多分支，抛出异常等复杂语句。 参考团灭前中后序遍历的递归+迭代lambda完整讲解","link":"/2020/03/15/python-lambda-expression/"}],"tags":[{"name":"django","slug":"django","link":"/tags/django/"},{"name":"closure","slug":"closure","link":"/tags/closure/"},{"name":"decorator","slug":"decorator","link":"/tags/decorator/"},{"name":"csrf","slug":"csrf","link":"/tags/csrf/"},{"name":"cors","slug":"cors","link":"/tags/cors/"},{"name":"middleware","slug":"middleware","link":"/tags/middleware/"},{"name":"vuerouter","slug":"vuerouter","link":"/tags/vuerouter/"},{"name":"restframework","slug":"restframework","link":"/tags/restframework/"},{"name":"reflection","slug":"reflection","link":"/tags/reflection/"},{"name":"token","slug":"token","link":"/tags/token/"},{"name":"hook","slug":"hook","link":"/tags/hook/"},{"name":"axios","slug":"axios","link":"/tags/axios/"},{"name":"vuex","slug":"vuex","link":"/tags/vuex/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"mermaid","slug":"mermaid","link":"/tags/mermaid/"},{"name":"lambda","slug":"lambda","link":"/tags/lambda/"},{"name":"recursion","slug":"recursion","link":"/tags/recursion/"},{"name":"binary tree","slug":"binary-tree","link":"/tags/binary-tree/"}],"categories":[{"name":"python","slug":"python","link":"/categories/python/"},{"name":"django","slug":"python/django","link":"/categories/python/django/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"closure","slug":"python/closure","link":"/categories/python/closure/"},{"name":"middleware","slug":"python/django/middleware","link":"/categories/python/django/middleware/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"vuerouter","slug":"vue/vuerouter","link":"/categories/vue/vuerouter/"},{"name":"lambda","slug":"python/lambda","link":"/categories/python/lambda/"},{"name":"restframework","slug":"python/django/restframework","link":"/categories/python/django/restframework/"},{"name":"hook","slug":"vue/hook","link":"/categories/vue/hook/"},{"name":"axios","slug":"vue/axios","link":"/categories/vue/axios/"},{"name":"vuex","slug":"vue/vuex","link":"/categories/vue/vuex/"},{"name":"start","slug":"hexo/start","link":"/categories/hexo/start/"},{"name":"UML","slug":"hexo/UML","link":"/categories/hexo/UML/"}]}