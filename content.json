{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"工具推荐","text":"在线图片压缩：wwei 注册有上传图片大小要求时，可以大幅压缩到满足要求的程度 文件夹压缩：7zip支持windows系统，Linux系统移步至此，不支持MacOS系统 在线PDF处理：ILovePDF格式转换，合并分离皆可，Chrome浏览器有支持插件 (当然最好选择还是Adobe acrobat)，mac OS可以通过内置的预览来对PDF进行拆分，合并排序操作。 Markdown编辑：typora 编辑响应快，所见即所得，可以选择语法偏好。","link":"/toolRecommand/index.html"},{"title":"前端学习笔记","text":"vue学习笔记 Vue学习笔记：vuex Vue学习笔记：vue-router Vue学习笔记：axios Vue学习笔记：hook Vue学习笔记：模板语言 Javascript学习笔记","link":"/frontend/index.html"}],"posts":[{"title":"Closure in python","text":"外函数的局部变量被内函数调取，当外函数执行完销毁时，被调用的变量会和内函数绑定避免销毁。 一：Python的闭包函数注意：var = func()是将func函数执行完的结果赋值给varvar = func是将func这个函数对象赋值给var 12345678910def outter_func(): fs = [] def inner_func(name): fs.append(name) print(fs) return inner_funcvar = outter_func()var('my') # print out ['my']var('name') # print out ['my','name'] outter_func按顺序执行 -&gt; 将inner_func函数对象作为结果返回给var -&gt; 返回后outter_func及其局部变量自动销毁，但fs被inner_func绑定，不会和outter_func一起销毁 -&gt; 成为inner_func私有变量 -&gt; 每次执行var('par')都会对fs造成累计改变。var中存放的，是由outter_func返回的inner_func对象，通过var('my')调用的是含有fs的inner_func('my')fs称为自由变量，可以用来记录闭包函数的每一次调用。外函数返回的对象为函数。 二：装饰器(语法糖)闭包函数中，返回值为对象这一特性的延伸。外函数的func参数会和func2进行绑定外函数的参数为函数对象，该对象在内函数中执行。不影响原有函数功能，可添加新功能。导入的第三方AIP无法重写时，可用装饰器进行修改。 1234567891011def func1(func): # 外函数的参数是被装饰函数对象 def func2(): print('this is func2') return func() # 返回的是函数func()的调用，即执行后的结果 return func2 # 返回的是函数对象@func1 def myprint(): print('hello')myprint() # 等同于 func1(myprint)() 函数myprint作为参数输入进func1中，且在内函数func2里被执行外函数func1返回的则是内函数对象。 三：带参数的装饰器在普通装饰器的基础上，增添一层函数来接收参数 1234567891011121314151617181920212223def func1(sex): def func2(func): # 内层和前面一样，在最外层嵌入一个`func1`来添加参数 def func3(): if sex == 'man': print('he is a man') if sex == 'woman': print('she is a woman') return func() return func3 return func2@func1(sex='man')def man(): print('human')@func1(sex='woman')def woman(): print('human')var1 = manvar2 = womanvar1() # he is a man humanvar2() # she is a human woman Django中，局部注销/添加 csrf token用到了带参数的装饰器。","link":"/2020/03/12/Closure-in-python/"},{"title":"REST Framework token","text":"HTTP协议是无状态协议，但是在用户操作时，需要通过用户的状态来进行不同的操作（比如登录与非登录的用户界面，功能不一样），token是解决这一问题的一种方法（还有session），其原理是在request中记录用户的状态（登录，未登录）。 一：token生成：基本流程如果通过用户信息验证，则生成一个token存储在response里，每一次访问server时，通过token确认是否是登录的用户。token的生成原理如下图所示 sequenceDiagram participant client participant server client->>server: 发送登录请求 server->>server: 验证用户信息 alt 验证通过 server->>server: 生成token server-->>client: 返回夹带token的response else 验证未通过 server-->>client: 返回携带err的response end 具体实现为了保证每一次登录生成的token都不一样，我选择将登录时间和用户名同时作为token参数 1234567def md5(username: str) -&gt; str: import hashlib # 局部引入md5加密算法 import time ctime = str(time.time()) # 生成时间戳 m = hashlib.md5(bytes(username, encoding='utf-8')) # username进行md5加密 m.update(bytes(ctime, encoding='utf-8')) # 加入时间戳加密 return m.hexdigest() 二：token原理：基本流程由于http协议自身无状态参数，通过token来记录当前用户的状态。可存放在cookie, body或是url（可能会有浏览器不支持或禁用cookie）。token的应用流程如下图所示： sequenceDiagram participant client participant server client->>server: 发送request server->>server: 验证request中的token alt 验证通过 server->>server: 执行相应的视图函数 server-->>client: 返回夹带token的response else 验证未通过 server-->>client: 返回携带err的response end 具体实现验证token时，加入对token的时间判断，如果和上一次访问时间差距过大（可能是非法攻击），则需要重新登录。 12345678910def confirm(self, *args, **kwargs): try: token = Token.objects.get(token=kwargs[\"token\"]) # token和user是一对一关系，所以用get if (timezone.now() - token.last_op_time).seconds &gt;= 30*60: # 判断距离上一次访问是否超过30分钟 raise exceptions.AuthenticationFailed(\"the token expired, login again\") else: token.save() # token里的时间属性带有auto_now字段，通过save可以激活时间属性自动更新时间 except Exception as e: raise exceptions.AuthenticationFailed(e.args) return token 三：通过REST Framework实现token认证REST Framework如何简化认证流程通常情况下，需要在每一个视图函数中都加入认证的方法，复杂项目中，某些视图函数会有多个认证，而有的函数则不需要。REST Framework给了我们管理这些认证的方法。在APIView源码中，有一个变量叫做authentication_classes的list变量： APIView部分源码1authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 而api_settings则是加载Django的setting文件中，REST Framework设置： api_settings部分源码123456api_settings = APISettings(None, DEFAULTS, IMPORT_STRINGS)def reload_api_settings(*args, **kwargs): setting = kwargs['setting'] if setting == 'REST_FRAMEWORK': api_settings.reload() Django settings文件内REST Framework的设置123REST_FRAMEWORK = { \"DEFAULT_AUTHENTICATION_CLASSES\": ['utils.auth.Authentication', ]} 所以authentication_classes是加载Django setting文件内设置的类。self.dispatch()-&gt; initialize_request()中的get_authenticators方法，会将authentication_classes里面的若干个类实例化去执行。所以在视图函数的类中，自定义authentication_classes来让REST Framework去初始化并执行需要的认证类。如果认证通过，则j执行视图函数，有问题则抛出异常。将认证类封装到同一个.py文件易于管理和调用。 Authentication类的实现1234567891011121314151617from loginapp import modelsfrom rest_framework import exceptionsfrom rest_framework.authentication import BaseAuthenticationclass Authentication(BaseAuthentication): def authenticate(self, request): token = request._request.GET.get('token') token_result = models.Token.objects.confirm(token=token) if not token_result: raise exceptions.AuthenticationFailed(\"user confirm failed\") else: return (token_result.user, token_result) def authenticate_header(self, request): pass BaseAuthentication是REST Framework的验证类，要实现认证必须继承它，并实现其中的authenticate和authenticate_header方法： BasicAuthentication源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class BasicAuthentication(BaseAuthentication): \"\"\" HTTP Basic authentication against username/password. \"\"\" www_authenticate_realm = 'api' # 此方法实现认证在子类必须重写的方法 def authenticate(self, request): \"\"\" Returns a `User` if a correct username and password have been supplied using HTTP Basic authentication. Otherwise returns `None`. \"\"\" auth = get_authorization_header(request).split() if not auth or auth[0].lower() != b'basic': return None if len(auth) == 1: msg = _('Invalid basic header. No credentials provided.') raise exceptions.AuthenticationFailed(msg) elif len(auth) &gt; 2: msg = _('Invalid basic header. Credentials string should not contain spaces.') raise exceptions.AuthenticationFailed(msg) try: auth_parts = base64.b64decode(auth[1]).decode(HTTP_HEADER_ENCODING).partition(':') except (TypeError, UnicodeDecodeError, binascii.Error): msg = _('Invalid basic header. Credentials not correctly base64 encoded.') raise exceptions.AuthenticationFailed(msg) userid, password = auth_parts[0], auth_parts[2] # 最后一步中，看出要返回的是一个元祖：(user,token)，并将其封装在request中 return self.authenticate_credentials(userid, password, request) def authenticate_credentials(self, userid, password, request=None): \"\"\" Authenticate the userid and password against username and password with optional request for context. \"\"\" credentials = { get_user_model().USERNAME_FIELD: userid, 'password': password } user = authenticate(request=request, **credentials) if user is None: raise exceptions.AuthenticationFailed(_('Invalid username/password.')) if not user.is_active: raise exceptions.AuthenticationFailed(_('User inactive or deleted.')) return (user, None) # 此方法实现认证在子类必须重写的方法（在方法内部直接写pass即可） def authenticate_header(self, request): return 'Basic realm=\"%s\"' % self.www_authenticate_realm 与BaseAuthentication同级的还有若干REST Framework封装好的验证类：TokenAuthentication，SessionAuthentication以及 BasicAuthentication，但是功能单一，不推荐使用。需要调用认证时在视图函数的类中直接初始化authentication_classes即可 调用认证12345# 在登录时，因为还没生成token所以局部取消认证，# 取消认证就是让 authentication_classes内部为空authentication_classes = []# 添加认证，就在authentication_classes内部添加即可authentication_classes = [Authentication]","link":"/2020/03/14/REST-Framework-token/"},{"title":"REST Framework reflaction","text":"当我们不知到类里有没有需要的属性以及方法时，通过反射来判断是否存在。 反射举例django处理HTTPresponse时，一般的写法如下所示: 12345678def view(request): if request.method == 'POST': ret = {'msg':'this is post method'} elif request.method == 'GET': ret = {'msg':'this is post method'} elif request.method == 'PUT': ret = {'msg':'this is post method'} return JsonResponse(ret) 首先通过request.method()判断请求方法，再根据不同的方法执行相应的语句。但是 REST framework中的APIView提供了一种机制：接收到request时，调用类中名称为request.method()的函数来执行： 12345678910111213141516171819202122232425262728293031class WordView(APIView): # add word def post(self, request, *args, **kwargs): try: ret = {\"words\": \"post\"} except Exception as e: ret = {\"error\": e.args} return JsonResponse(ret) # get word def get(self, request, *args, **kwargs): try: ret = {\"words\": \"get\"} except Exception as e: ret = {\"error\": e.args} return JsonResponse(ret) # delete word def delete(self, request, *args, **kwargs): try: ret = {\"words\": \"del\"} except Exception as e: ret = {\"error\": e.args} return JsonResponse(ret) def put(self, request, *args, **kwargs): try: ret = {\"words\": \"put\"} except Exception as e: ret = {\"error\": e.args} return JsonResponse(ret) APIView实现上述机制的原理（反射）:APIView会执行self.dispatch(): dispatch部分源码12345678910111213141516171819try: self.initial(request, *args, **kwargs) # Get the appropriate handler method # 判断request请求方法是否为HTTP规定的单词 # http_method_names = ['get', 'post', 'put', 'patch', 'delete', 'head', 'options', 'trace'] if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), # handler拿到函数名与请求方法名称一致的函数 self.http_method_not_allowed) # 如果没拿到，返回http_method_not_allowed 状态码为405 else: handler = self.http_method_not_allowed response = handler(request, *args, **kwargs)except Exception as exc: response = self.handle_exception(exc)self.response = self.finalize_response(request, response, *args, **kwargs)return self.response 从中也可以看出，APIView所支持的请求方法。","link":"/2020/03/13/REST-Framework-reflection/"},{"title":"Django cross-site","text":"CSRF保护跨站点请求伪造保护是一种防范特定类型攻击的机制，当用户尚未从网站注销并继续拥有有效会话时，就会发生这种攻击。在这种情况下，恶意站点可以在登录会话的上下文（cookies）对目标站点执行操作。 方法此类攻击，需要保证三件事： 安全的HTTP操作，不能用于更改任何服务器状态和数据，比如：GET, OPTIONS和HEAD 其余不安全的操作，则需要CSRF令牌。 除此之外，还要保证记录回话状态的数据（session，token等）的安全性（加密，设置存活时间）。Django中，csrf令牌的验证是在中间件内执行的，确切地说，是在中间件的process view中执行，因为中间件要判断路由对应的视图函数是否需要进行令牌验证（Django可通过装饰器局部注销验证） CSRF保护的流程如图所示： sequenceDiagram participant client participant server client->>server: 发送页面请求 server-->>client: 返回夹带csrf令牌的页面响应 client->>server: 发送夹带csrf的请求（包含token） server->>server: 验证令牌 alt csrf验证通过 server->>server: 验证token alt token验证通过 server->>server: 执行视图函数 server-->>client: 返回响应 else token验证未通过 server-->>client: 返回携带err的response end else csrf验证未通过 server-->>client: 返回携带err的response end 而跨站攻击就是在没有csrf令牌的保护下，hacker获取会话状态信息来生成对服务器数据或状态改变的http请求 sequenceDiagram participant client participant server participant hacker client->>server: 发送登录请求 server-->>client: 返回夹带token的响应 hacker->>client: 发送恶意链接 client->>hacker: 点击恶意链接后，hacker拿到你的token hacker->>server: 将获取的token加入请求，发送改变服务器数据的请求 server->>server: 验证通过，并执行相应的视图函数 跨站攻击，防御的核心是防止token被挟持可以通过令牌进行跨站攻击的防御 CORS一些部署在集群中的微服务，前后端是整体分离的，前端在和后端交互时，因为 ip+port必定不一样，所以就产生了跨站请求。 同源策略同源策略，即前后端的ip和端口号一致时，请求才能成功，不然会有跨站攻击的嫌疑，服务器会禁止这种请求，同源策略从一定程度上避免了跨站攻击，但是这样也影响了正常的前后端分离系统的交互。为了让前后端分离系统的交互能正常进行，则有了CORS。分为简单请求和复杂请求，浏览器会在请求头部自动添加信息，所以只需在服务器实现接口即可。 简单请求 方法为head，get，post。 头部不设置除此以外的字段：Accept，Accept-Language，Content-Language，Last-Event-ID，Content-Type（仅限于application/x-www-form-urlencoded、multipart/form-data、text/plain） 以上条件，缺一即为复杂请求 简单请求仅需要一次请求，在头部增加 Access-Control-Allow-Origin = '域名' 或 '*'字段即可 复杂请求 除简单请求以外的，皆为复杂请求 复杂请求会有两次请求：第一次为OPTIONS方法的预检请求，由于复杂请求时，首先会发送“预检”请求，如果“预检”成功，则发送真实数据。“预检”请求时，允许请求方式则需服务器设置响应头：Access-Control-Request-Method和Access-Control-Request-Headers Django CORS中间件的实现django-cors-headers GitHub官方文档 参考Ajax，CSRF&amp;CORS-Django REST框架Django中CSRF防御全过程解析以及中间件作用机制","link":"/2020/03/19/Django-cross-site/"},{"title":"Hexo UML diagram","text":"写博客时，需要添加UML图，但hexo的markdown不自带UML图渲染功能，所以通过安装hexo-filter-mermaid-diagrams插件来实现功能。 一：mermaid安装安装参考我的主题是icarus，没有after_foot.ejs文件，所以和hexo-filter-mermaid-diagrams的官方安装指南的step3有些差别，这里我除了官网的文档，还参考了一位和我使用同一主题的博主的配置方法，和他的唯一区别是我的icarus是最新版，他的老一些。要看他的博客可能需要“科（v）学（p）上（n）网”。 安装流程首先通过npm下载hexo-filter-mermaid-diagrams： 1npm i hexo-filter-mermaid-diagrams 其次在hexo根目录下的_config.yml文件的最后面加入如下配置： 123456# mermaid chartmermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: &quot;7.1.2&quot; # default v7.1.2 options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js #startOnload: true // default true 提示：如果需要类图，在_config.yml文件中设置external_link: false。最后，需要在自定义主题文件下添加代码，使用的主题不一样，添加的位置也不一样，使用icarus主题的可以参考本篇文章，我参考了前面说的这位博主；next主题网上很多可以搜到，其他主题移步官方文档查看。在\\themes\\icarus\\layout\\common\\footer.ejs中添加mermaid渲染： 123456789101112131415161718192021222324252627&lt;div class=&quot;level-end&quot;&gt;&lt;% if (Object.keys(links).length) { %&gt; &lt;div class=&quot;field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle&quot;&gt; &lt;% for (let name in links) { let link = links[name]; %&gt; &lt;p class=&quot;control&quot;&gt; &lt;a class=&quot;button is-white &lt;%= typeof(link) !== 'string' ? 'is-large' : '' %&gt;&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;&lt;%= name %&gt;&quot; href=&quot;&lt;%= url_for(typeof(link) === 'string' ? link : link.url) %&gt;&quot;&gt; &lt;% if (typeof(link) === 'string') { %&gt; &lt;%= name %&gt; &lt;% } else { %&gt; &lt;i class=&quot;&lt;%= link.icon %&gt;&quot;&gt;&lt;/i&gt; &lt;% } %&gt; &lt;/a&gt; &lt;/p&gt; &lt;% } %&gt; &lt;/div&gt;&lt;% } %&gt;//included mermaid&lt;% if (theme.mermaid.enable) { %&gt; &lt;script src='https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js'&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) { mermaid.initialize({theme: 'neutral'}); } &lt;/script&gt;&lt;% } %&gt;&lt;/div&gt; //included mermaid处为添加的代码。不要把//included mermaid复制进去，这个注释只是说明复制的位置和代码。如果复制了，页脚会把它也渲染进页面。 二：UML图语法画图没什么好说的，语法参考官方文档。如果画图语法错误，没有报错，只会在文章中空白显示，这里推荐一个在线mermaid编辑器检查语法，也可以将图转化为png或svg文件。网上的mermaid语法格式因为markdown编辑器不一而存在差异，本方法仅测试hexo下的可用性，其他种类的博客请酌情使用。","link":"/2020/03/15/hexo-UML-diagram/"},{"title":"Python lambda expression","text":"lambda表达式可执行简单语句，多用于对list的处理。 lambda表达式 表达式参数lambda arg_list: expressionarg_lists是输入参数的形式，接受有的输入，比如: 12345a=1, 6*args**kargs[x, y]None expression则是简单的，单行语句，且需要的参数都在arg_lists中定义： 12341Nonea+b1 if a &gt; 0 else 2 表达式特性表达式有输入输出： 输入为arg_list，输出为expression的返回值函数匿名： lambda函数没有名称，不配拥有姓名功能有限： 其格式已经决定了只能用于简单的语句结构 应用场景将lambda函数赋值给变量，使得lambda函数拥有姓名12add = lambda x, y: x + yadd(1, 2) # 加法功能函数 输出为3 用lambda函数替换掉别的函数12time.sleep(3) #程序sleep三秒time.sleep = lambda x: print('HAHA') # 将sleep函数的内部替换为lambda函数，无论sleep的输入是多少，都会执行print('HAHA') lambda作为函数对象被返回给调用者闭包函数123456def outter(): fs = ['a', 'b', 'c'] return lambda x: fs.pop()a = outter()print(a(1)) # 输出cprint(a(1)) # 输出b lambda作为参数被python函数使用filter()此时lambda函数用于指定过滤列表元素的条件。例如filter(lambda x: x % 3 == 0, [1, 2, 3])指定将列表[1,2,3]中能够被3整除的元素过滤出来，其结果是[3] sorted()此时lambda函数用于指定对列表中所有元素进行排序的准则。例如sorted([1, 2, 3, 4, 5, 6, 7, 8, 9], key=lambda x: abs(5-x))将列表[1, 2, 3, 4, 5, 6, 7, 8, 9]按照元素与5距离从小到大进行排序，其结果是[5, 4, 6, 3, 7, 2, 8, 1, 9]。 map()此时lambda函数用于指定对列表中每一个元素的共同操作。例如map(lambda x: x+1, [1, 2,3])将列表[1, 2, 3]中的元素分别加1，其结果[2, 3, 4]。 reduce()：先对集合中第1，2个元素操作，得到的结果和第三个元素进行操作，以此类推此时lambda函数用于指定列表中两两相邻元素的结合条件。例如reduce(lambda a, b: ‘{}, {}’.format(a, b), [1, 2, 3, 4, 5, 6, 7, 8, 9])将列表 [1, 2, 3, 4, 5, 6, 7, 8, 9]中的元素从左往右两两以逗号分隔的字符的形式依次结合起来，其结果是’1, 2, 3, 4, 5, 6, 7, 8, 9’。 lambda表达式在递归的应用leetcode 第144题 1234def preorfer(root: TreeNode) -&gt; List[int]: # 前序写法，中序后序类似 p = lambda x: [x.val] + p(x.left) + p(x.right) if x else [] return p(root) 但是这种递归只能用于执行语句简单时，lambda不支持多分支，抛出异常等复杂语句。 参考团灭前中后序遍历的递归+迭代lambda完整讲解","link":"/2020/03/15/python-lambda-expression/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.官方文档中文版请移步至此 Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server123$ hexo server# shorthand as:$ hexo s More info: Server Generate static files123$ hexo generate# shorthand as:$ hexo g More info: Generating Deploy to remote sites123$ hexo deploy# shorthand as:$ hexo d 通过Netlify免费加速参考文章亲测有效通过Netlify免费加速 More info: Deployment","link":"/2020/03/15/hello-world/"},{"title":"Vue笔记：axios","text":"axios简介每个前端框架，都会有类似ajax的异步请求来从后台获取参数（通常是通过钩子函数调用），Vue则是通过axios进行异步请求。 axios使用（集合血与泪之后的推荐方案）在vue组件内直接加入axios，会导致高耦合，如果要修改某些aixos配置，需要找到各个组件内的axios请求进行修改，如果axios停止维护，所有组件内的异步请求需要全部修改。所以需要将axios从组件内抽离和封装来解耦， axios 异步请求的建立： 在新建的文件./src/request.js中添加如下代码123456789101112131415161718import axios from 'axios'// 设置全局的基础urlaxios.defaults.baseURL = 'http://127.0.0.1:8000';// 通过export导出多个实例 export default只能导出一个实例export function loginRequest(config){ //创建axios实例 const loginRequest = axios.create({ url: '/api/login/confirmAuth/', timeout: 10000, method: 'post', headers:{ 'Content-Type': 'application/json', } }); // 发送真正的网络请求 return loginRequest(config) //如果有一天，此axios无法使用，在loginRequest内重构新代码，return Promise(config)即可} axios在组件中使用（建立请求以及处理响应）： 在Vue组件内导入js文件并直接调用12345678910111213141516171819202122//封装request模块import {loginRequest} from \"../request\";methods: { login:function(){ //直接引用request中封装好的loginRequest即可 loginRequest({ data: { \"username\": this.usr, \"password\": this.pwd, } }).then(res =&gt;{ // 在then里面，拿取返回的结果并进行进一步操作（跳转，或初始化参数） console.log(res.status); if (res.status == 200){ // res.data.token：拿取返回的响应体内的参数token this.$router.replace({path: '/homepage', query: {token: res.data.token}}) } }).catch(res =&gt; { console.log(res); }) }}, axios传参 params传参将上文的请求改为params传参12345678910111213141516loginRequest({ url: '/api/login/confirmAuth/', // 此处添加 params参数的内容 params: { \"username\": a, \"password\": b, }}).then(res =&gt;{ console.log(res.status); if (res.status == 200){ this.$router.replace({path: '/homepage', query: {token: res.data.token}}) }}).catch(res =&gt; { console.log(res);})// 最后得到的url是 /api/login/confirmAuth?username=a&amp;password=b data传参data传参参考上文axios的使用 axios全局设置全局设置会使得设置的aixos参数在前端任意组件内都可使用，在request.js文件中如下设置 12axios.defaults.baseURL = 'http://127.0.0.1:8000';axios.defaults.headers['Content-Type'] = 'application/json'; 并发axios拦截器遇到的问题main.js不能用use配置 Uncaught (in promise) TypeError: Cannot read property ‘protocol’ of undefined 参考Axios（自定义配置新建一个 axios 实例并且封装起来）Axios发送请求时params和data的区别","link":"/2020/03/24/vuenote/Vuenote-axios/"},{"title":"Vue笔记：v系列关键词","text":"简介mustache将组件内定义的变量显示在模板里 在组件 script 标签内声明变量123456789101112131415&lt;script&gt; data(){ return { msg: 'hello', counter: 100, } },&lt;/script&gt;&lt;!--在templete标签内可以调用msg变量--&gt;&lt;templete&gt; &lt;h2&gt;{{this.msg}}&lt;/h2&gt; &lt;!--mustache可以进行简单的运算 --&gt; &lt;h2&gt;{{counter * 2}}&lt;/h2&gt;&lt;/templete&gt; 仅能在DOM的内容处使用:&lt;h2&gt;&lt;/h2&gt;, 不能在DOM的其他部分使用比如&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;，src渲染出来的就是纯字符串，在DOM属性内添加data内的变量，移步至v-bind v-once一直数据初始化的值，即使后期数据改变，也不会改变其显示 在组件 script 标签内声明变量1234567891011121314&lt;script&gt; data(){ return { msg: 'hello', counter: 100, } },&lt;/script&gt;&lt;!--在templete标签内可以调用msg变量--&gt;&lt;templete&gt;&lt;!--即使后面this.msg的值改变了，仍然显示hello--&gt; &lt;h2 v-once&gt;{{this.msg}}&lt;/h2&gt;&lt;/templete&gt; v-cloak在script解析时，如果速度过慢，会导致DOM元素显示的是mustache占位符，比如,而不是this.msg的值，直到script加载渲染完成，才会显示this.msg的值，为了避免这种情况，在标签内加入v-cloak,使得DOM元素不显示直到this.msg加载完成。 123&lt;templete&gt; &lt;h2 v-cloak&gt;{{this.msg}}&lt;/h2&gt;&lt;/templete&gt; v-bind给DOM元素的属性绑定data内变量 1234567891011&lt;templete&gt; &lt;!--语法糖，DOM属性前面加: 表示通过v-bind声明要绑定data内元素--&gt; &lt;img :src=\"this.img\" alt=\"\"&gt;&lt;/templete&gt;&lt;script&gt; data(){ return { img: 'www.XX.com' } }&lt;/script&gt; v-bind是单向绑定，即data中绑定的变量改变，会引起对应DOM属性改变。而v-model则是双向绑定，且v-blind绑定的是data内变量和DOM属性。v-model则是DOM内显示的变量和data变量。 v-model1&lt;input type=\"yourbirth\" v-model=\"yourbirth\" name=\"\" placeholder=\"你的生日是什么时候?\"&gt; v-if和v-else当满足v-if的条件时，进行渲染，否则不渲染 v-if 和v-else和计算机语言中的if else一样 1234&lt;!--当 this.isShow==true 时，才会渲染--&gt;&lt;h2 v-if=\"this.isShow\"&gt;哈哈&lt;/h2&gt;&lt;!--除了if以外的所有情况，渲染下面的DOM--&gt;&lt;h2 v-else&gt;嘿嘿&lt;/h2&gt; v-if, v-else结合使用和python的if elif使用一样 12345&lt;h2 v-if=\"score=90\"&gt;=优秀&lt;/h2&gt;&lt;h2 v-else-if=\"score&gt;=80\"&gt;不错&lt;/h2&gt;&lt;h2 v-else-if=\"score&gt;=70\"&gt;还可以&lt;/h2&gt;&lt;h2 v-else-if=\"score&gt;=60\"&gt;一般般&lt;/h2&gt;&lt;h2 v-else=\"score&gt;=50\"&gt;不好呀&lt;/h2&gt; v-if和·v-show的区别：v-if条件为false，模板中不会有对应的DOM，当v-if的条件变为true时，新建一个DOM，false时删除，v-show则是在DOM中添加了display=none。切换的DOM频率较高，使用v-show，否则使用v-if。 v-show作用和v-if一样！ 1234567&lt;!--看this.showPop的值是否为true true则显示--&gt;&lt;form class=\"Login\" v-show=\"!showPop\" @submit.prevent=\"login\"&gt; &lt;h1&gt;没奖竞猜&lt;/h1&gt; &lt;input type=\"yourbirth\" v-model=\"yourbirth\" name=\"\" placeholder=\"你的生日是什么时候?\"&gt; &lt;input type=\"mybirth\" v-model=\"mybirth\" name=\"\" placeholder=\"我的生日是什么时候?\"&gt; &lt;input type=\"submit\" name=\"\" value=\"Login\"&gt;&lt;/form&gt; v-if和·v-show的区别：v-if条件为false，模板中不会有对应的DOM，当v-if的条件变为true时，新建一个DOM，false时删除，v-show则是在DOM中添加了display=none。切换的DOM频率较高，使用v-show，否则使用v-if。 v-on绑定一个监听事件，简写为@ 基本使用:12345678910111213141516171819202122232425&lt;template&gt; &lt;!--将counter属性 -1 --&gt; &lt;button @click=\"counter--\"&gt;-&lt;/button&gt; &lt;!--执行this.setcounter方法--&gt; &lt;!--调用增强型函数且无参数输入时，不写()--&gt; &lt;button @click=\"this.setcounter\"&gt;setcounter&lt;/button&gt; &lt;!--调用的函数需要传入参数时--&gt; &lt;button @click=\"this.setcounter1(2)\"&gt;setcounter&lt;/button&gt;&lt;/template&gt;&lt;script&gt; data(){ return{ counter = 1, } }, methods:{ //函数增强写法，调用函数时，和调用属性一样不加（） setcounter(){ this.counter = 2 * counter } setcounter1(c){ this.counter = c * 2 } }&lt;/script&gt; 修饰符修饰符就是对监听事件的触发加一些限定：@click就是在点击鼠标时才会触发，@submit.prevent就是阻止了默认action的情况下再去触发。 prevent阻止默认事件，执行新定义的事件（通常用来阻止form表单提交） 1234567&lt;!--阻止默认form提交，去执行login方法--&gt;&lt;form class=\"Login\" v-show=\"!showPop\" @submit.prevent=\"login\"&gt; &lt;h1&gt;login&lt;/h1&gt; &lt;input type=\"yourbirth\" v-model=\"yourbirth\" name=\"\" placeholder=\"usernmae\"&gt; &lt;input type=\"mybirth\" v-model=\"mybirth\" name=\"\" placeholder=\"password\"&gt; &lt;input type=\"submit\" name=\"\" value=\"Login\"&gt;&lt;/form&gt; stop阻止冒泡事件，冒泡事件的产生如下所示： 12345&lt;template&gt; &lt;div @click=\"divevent\"&gt; &lt;button @click=\"butevent\"&gt;按钮&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 如果点击button 则divevent和butevent都会执行，想在点击button时，只执行butevent，添加stop关键字 12345&lt;template&gt; &lt;div @click=\"divevent\"&gt; &lt;button @click.stop=\"butevent\"&gt;按钮&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 键盘 123456&lt;!--keyup：键冒按下去不会触发，放松手键帽反弹时，触发submit方法，对应的还有keydown方法--&gt;&lt;input type=\"text\" @keyup=\"submit\"&gt;&lt;!--keyup.enter：enter键松手反弹时，触发submit方法--&gt;&lt;input type=\"text\" @keyup.enter=\"submit\"&gt;&lt;!--once：和v-once一样--&gt;&lt;input type=\"text\" @once=\"submit\"&gt; keyup和keydown支持监控所有键盘，键盘的编码可以百度查找 v-forv-for ? 字面意思，就是循环遍历 遍历数组1234567891011121314151617181920212223&lt;template&gt;&lt;!--建议在使用v-for的元素下，绑定一个:key元素，这个元素是要和后面显示的内容为一一对应的--&gt; &lt;!--在遍历过程中，获取每一个item的值--&gt; &lt;li v-for= \"item in names\" :key=\"item\"&gt;{{item}}&lt;/li&gt; &lt;!--在遍历过程中，获取索引--&gt; &lt;li v-for= \"(item, index) in names\" :key=\"item\"&gt;{{index}}, {{item}}&lt;/li&gt; &lt;!--对象的遍历,如果只获取一个值，则item显示出的为value，不显示key--&gt; &lt;li v-for= \"item in info\" :key=\"item\"&gt;{{item}}&lt;/li&gt; &lt;!--如果要同时获取value和key，则如下操作--&gt; &lt;li v-for= \"(value, key) in info\"&gt;{{value}}, {{key}}&lt;/li&gt;&lt;/template&gt;&lt;script&gt; data(){ return{ names:['a', 'b', 'c', 'd'], info:{ fname: 'a', lname: 'b', sex: 'f' } } }&lt;/script&gt; 参考","link":"/2020/03/24/vuenote/Vuenote-templete/"},{"title":"Vue笔记：vue-router","text":"vue-router简介vue-router的功能是通过前端路由来调取对应的插件，和后端的url路由类似（后端是通过路由执行对应视图函数）， vue-router基础使用 npm install vue-router --save安装 如果创建vue app时，选择了vue-router，在src/router目录有一个有index.js 文件,内部搭好了router结构，直接按下面代码创建路由列表即可，如果创建vue app时，没选择加载vue-router 则按如下方法创建:在项目根目录下创建 router.js 并在里面添加如下代码123456789101112131415161718192021222324252627282930313233343536import Vue from 'vue'import VueRouter from 'vue-router'// 以下是要添加路由的组件import Nav from './components/homeComponents/Nav.vue'import Login from './components/Login.vue'// 将vue-router安装至vue中Vue.use(VueRouter);// 创建路由列表const routes=[ //单个路由均为对象类型，path代表的是路径，component代表组件 //处理特殊情况的代码（例如重定向）写在最前面 { // 如果输入的path为空 则重定向到'/login' path:'', redirect:'login' }, { // path是和组件绑定的路径（不要写成url） path:'/homepage', component:Nav }, { path:'/login', component:Login },];//实例化VueRouter并将routes添加进去const router=new VueRouter({//ES6简写，等于routes：routes routes});//抛出这个这个实例对象方便外部读取以及访问export default router 在main.js中。作如下修改：123456789101112131415// 在main.js文件开头进行如下设置：// 将vuex注册进入vue内Vue.use(Vuex);// 引入 router.js文件，下一步在文件的结尾处挂载import router from './router.js'Vue.config.productionTip = false;// 在文件结尾的new Vue处，挂载引入的router文件new Vue({ render: h =&gt; h(App), // 将router挂载进app.vue router, // 添加history模式，使得加载的url为html模式（刷新不会出现xxx/#/login的情况） mode: 'history'}).$mount('#app'); 在 App.vue的中，加入以下代码：12345678910111213&lt;template&gt; &lt;div id=\"app\"&gt; /*router-link在浏览器会被渲染为a标签*/ /*router-link内，to后面的path则是a标签的链接*/ /*不想将router-link渲染为a标签，增加tag属性转换为其他标签*/ /*点击login和homepage两个button后，发现可以通过浏览器的后退返回到点击之前的页面状态，在单页面应用是不允许的，设置replace阻止返回*/ /*replace的原理在下一章节 vue-router路由跳转解释*/ &lt;router-link to=\"/login\" tag=\"button\" replace&gt;login&lt;/router-link&gt; &lt;router-link to=\"/homepage\" tag=\"button\" replace&gt;homepage&lt;/router-link&gt; /*router-view接收每个router-link对应path的组件并显示*/ &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 使用history模式时，会出现用户在未登录的情况下，直接访问登录后的功能或页面，在后台要有机制去处理未授权的请求，前端axios也要注意从后台catch错误时，要如何处理（强行访问未授权的部分，应当是返回登录界面） router-link的用法解析 router-link标签会渲染成a标签，通过tag来将其转化为其他标签，转换完，可添加class方便其进行渲染 12/*前端会渲染其成为class为submit的button*/&lt;router-link to=\"/login\" tag=\"button\" class=\"submit\" replace&gt;login&lt;/router-link&gt; vue-router路由跳转路由跳转，有两种实现：第一种是replace, 即路由跳转后，无法退回之前的状态（浏览器无法使用后退键），第二种就是push实现，即可以退回历史状态 在vue组件内如下实现12345//路由必须是配置过的路由（参考文章前一部分）// 跳转到不同的url，但这个方法会向history栈添加一个记录，点击后退会返回到上一个页面。this.$router.push('/homepage');// 同样是跳转到指定的url，但是这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。this.$router.replace('/homepage'); 路由传参动态路由（params传参）类似http请求的RESTful样式（www.a.com/product/1 和 www.a.com/product/2 调用的是同一视图函数 将对应编号的product数据返回给前端）以下是设置动态路由 在router.js的路由列表中如下设置1234567891011121314151617const routes=[ //单个路由均为对象类型，path代表的是路径，component代表组件 //特殊情况的代码写在最开始， { path:'', redirect:'login' }, { //路由中 /:token即为动态的部分 path:'/homepage/:token', component:Nav }, { path:'/login', component:Login },]; 在vue组件中要跳转的部分添加如下代码12//将axios中返回响应体内的token和path做拼接this.$router.replace(\"/homepage/\"+res.data.token); 设置完成后，在被路由调用的组件内，拿到动态路由所传的值 在被调用的组件内加入12345678computed:{ token(){ // $route所拿到的路由是目前正活跃的路由 // $router是获取路由列表内所有的路由 // params.后面跟的参数要和router.js 设置的路由参数一样 return this.$route.params.token }}, query传参当有路由嵌套时，无法通过params传参，此时要query传参。 在router.js中配置路由配置（常规配置）1234{ path:'/homepage', component:() =&gt; import('./components/homeComponents/Nav.vue')}, 在组件的文件内加入以下代码来传递参数1234// replace内传递的为对象：向路径为 /homepage的组件传递 token为res.data.token内的值this.$router.replace({path: '/homepage', query: {token: res.data.token}})// 或者通过router-link来进行query传参&lt;router-link :to=\"{path:'/login', query:{token: this.res.res.data.token}}\" tag=\"button\" class=\"submit\" replace&gt;login&lt;/router-link&gt; 在接收参数的组件内加入this.$query.token来接受参数1234567computed:{ token(){ // $route所拿到的路由是目前正活跃的路由 // $router是获取路由列表内所有的路由 return this.$route.query.token }}, 懒加载（按需加载）vue的所有路由下的组件会打包在一个js文件中，当主页面加载时，其余页面也会同时加载。如果项目组件数量巨大，同时加载速度很慢，其中有些x组件需要及时加载（首页，新闻，产品推送），有些则不需要（设置，账户管理这些首页默认不会显示），设置懒加载项目打包时会分在不同js文件下，用户在使用组件时才会加载。 在router.js的路由列表中如下设置1234567891011121314151617const routes=[ //单个路由均为对象类型，path代表的是路径，component代表组件 //特殊情况的代码写在最开始，如果写在最后，后期可能会在后面加代码，特殊情况的代码就难找到了 { path:'', redirect:'login' }, { //路由中 /:token即为动态的部分 path:'/homepage/:token', component:() =&gt; import('./components/homeComponents/Nav.vue') }, { path:'/login', component:() =&gt; import('./components/Login.vue') },]; 路由的嵌套路由的嵌套类似于后台路由的二次分配，在前端，有一个组件A 其路由为 /A, 他有两个子组件为A1和A2， 子组件的路由应为 /A/A1 和 /A/A2, 如何分配路径，就是路由的嵌套。 在router.js中配置路由1234567891011121314151617181920212223242526const routes=[ { path:'/homepage', component:() =&gt; import('./components/homeComponents/Nav.vue'), //在父子件下加入children为关键字的子路由列表（懒加载形式） children:[ { path: 'anniversary', component:() =&gt; import('./components/homeComponents/Anniversary.vue') }, { path: 'clock', component:() =&gt; import('./components/homeComponents/Clock.vue') }, { path: 'photos', component: () =&gt; import('./components/homeComponents/Photos.vue') }, { path: 'words', component: () =&gt; import('./components/homeComponents/Words.vue') }, ] },]; 在vue的模板内这样调用12345678&lt;div class=\"NavButtons\"&gt; &lt;h1&gt;HomePage&lt;/h1&gt; &lt;div&gt;&lt;router-link to=\"/homepage/photos\" tag=\"button\" class=\"submit\" replace&gt;照 片&lt;/router-link&gt;&lt;/div&gt; &lt;div&gt;&lt;router-link to=\"/homepage/anniversary\" tag=\"button\" class=\"submit\" replace&gt;纪念日&lt;/router-link&gt;&lt;/div&gt; &lt;div&gt;&lt;router-link to=\"/homepage/clock\" tag=\"button\" class=\"submit\" replace&gt;计 时&lt;/router-link&gt;&lt;/div&gt; &lt;div&gt;&lt;router-link to=\"/homepage/words\" tag=\"button\" class=\"submit\" replace&gt;想说的话&lt;/router-link&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=\"button\" name=\"\" value=\"返 回\" @click=\"returnToLogin\"/&gt;&lt;/div&gt;&lt;/div&gt; 路由导航守卫路由跳转或在路由跳转时执行一些函数（类似于钩子函数），通过全局的路由导航守卫来监听并且执行。没有用过，等以后更新哈 遇到的问题 [Vue warn]: Unknown custom element: - did you register the component correctly? For recursive components, make sure to provide the “name” option.router-link 的tag不能使用submit要用button 参考Vue路由（vue-router）详细讲解指南vue-router中文文档vue-router的push和replace的区别","link":"/2020/03/24/vuenote/Vuenote-vue-router/"},{"title":"Vue笔记：钩子函数&options","text":"vue 钩子函数特征介绍 生命周期 是否获取dom节点 是否可以获取data 是否获取methods beforeCreate 否 否 否 created 否 是 是 beforeMount 否 是 是 mounted 是 是 是 beforeUpdate 是 是 是 updated 是 是 是 计算属性通过计算属性会进行缓存，多次调用时，只要与其相关的参数不变，计算属性只会计算一次 基本使用在vue组件script标签下添加12345678910111213data:{ firstname: 'FIFA' lastname: 'z'}//我想输出时，将firstname和lastname进行拼接后输出computed:{ //以调用参数的形式调用此方法:&lt;h2&gt;{{this.fullname}}&lt;h2&gt; //因为是计算属性，是属性，所以命名时，用属性的方式命名（名词命名） //fullname，不是getfullname fullname(){ return this.firstname+' '+this.lastname }} 计算属性的getter和setter方法添加位置和前面一样123456789101112computed:{ fullname:{ //计算属性一般为只读属性，所以几乎不会用到set方法 //推荐前面的方法 set(){ //so sth } get(){ return this.firstname+' '+this.lastname } }} vue的options el: 类型：string或HTMLElement 决定Vue实例会挂载到哪一个DOM methods：类型： function属于vue的方法，可在整个组件内进行调用 data: 类型：obj或function（组件当中，data必须是函数） vue内部对应的数据对象方法：定义在类里面函数：free 参考vue中created与mounted区别","link":"/2020/03/24/vuenote/Vuenote-hook&option/"},{"title":"Vue笔记：vuex","text":"vuex简介Vuex 是一个专为 Vue.js集中式存储管理多个组件共享的变量。比如：多个兄弟组件之间共用同一个参数来调整自己的状态，传参的方法对于多层嵌套的组件将会非常繁琐。跨组件传参，有全局变量时，使用vuex传参。 vuex使用 首先通过npm install vuex来安装vuex 在main.vue中，作如下声明：1234567891011121314151617181920212223242526272829303132333435363738394041424344// 首先&lt;script&gt;下导入vueximport Vuex from 'vuex'// 将vuex安装进vueVue.use(Vuex);const store = new Vuex.Store({ // state用来声明变量并初始化 state:{ pageStatus: 0, token: \"\" }, // state内的变量不能直接修改，通过调取mutations内的方法进行修改 // mutation内实现了三个方法：pageStatus的加，减以及字符串token的赋值 mutations:{ // 将pageStatus变量 +1 increase(state){ state.pageStatus += 1; }, // 将pageStatus变量 +1 decrease(state){ state.pageStatus -= 1; }, // 将token赋值，注意要声明输入的参数str set_token(state, str){ state.token = str } }, // state内的变量不能直接获取，要通过getters方法声明 getters:{ // 获取 token get_token(state){ return state.token } }, actions:{ }});new Vue({ render: h =&gt; h(App), router, // 将store挂载进app.vue store}).$mount('#app'); 在自定义的组件内，声明如下：首先在computed获取变量,在methed获取变量对应的get set方法12345678910111213141516171819//在 &lt;script&gt; 标签下导入import {mapState} from 'vuex';//在 &lt;script&gt; 下的computed获取全局变量，method中获取get set方法：computed:{ // 获取全局变量 ...mapState(['pageStatus', \"token\"])},methed:{ // 获取全局变量所对应的get set方法 ...mapState([\"increase\", \"decrease\", \"set_token\"]), returnToLogin:function(){ // 通过调用 main.js的mutations中decrease方法，使得 pageStatus -= 1 this.$store.commit('decrease'); // 通过 increase方法来改变token的值（即 global token = this.token） this.$store.commit('set_token', this.token); this.toClock();} 通过上述方法后，变量可以在vue的模板内进行调用vue组件的模板内1&lt;div v-show=\"pageStatus == 0\"&gt;&lt;/div&gt; 遇到的异常 [Vue warn]: The computed property “token” is already defined in data.组件中data声明的变量名称与vuex 中设置的全局变量一样导致报错，即vuex中有名为token的变量，组件的data中也声明了名为token的变量，解决方法：重新命名组件内的变量。","link":"/2020/03/24/vuenote/Vuenote-vuex/"}],"tags":[{"name":"django","slug":"django","link":"/tags/django/"},{"name":"closure","slug":"closure","link":"/tags/closure/"},{"name":"decorator","slug":"decorator","link":"/tags/decorator/"},{"name":"restframework","slug":"restframework","link":"/tags/restframework/"},{"name":"token","slug":"token","link":"/tags/token/"},{"name":"reflection","slug":"reflection","link":"/tags/reflection/"},{"name":"csrf","slug":"csrf","link":"/tags/csrf/"},{"name":"cors","slug":"cors","link":"/tags/cors/"},{"name":"middleware","slug":"middleware","link":"/tags/middleware/"},{"name":"mermaid","slug":"mermaid","link":"/tags/mermaid/"},{"name":"lambda","slug":"lambda","link":"/tags/lambda/"},{"name":"recursion","slug":"recursion","link":"/tags/recursion/"},{"name":"binary tree","slug":"binary-tree","link":"/tags/binary-tree/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"axios","slug":"axios","link":"/tags/axios/"},{"name":"v-if","slug":"v-if","link":"/tags/v-if/"},{"name":"vuerouter","slug":"vuerouter","link":"/tags/vuerouter/"},{"name":"hook","slug":"hook","link":"/tags/hook/"},{"name":"options","slug":"options","link":"/tags/options/"},{"name":"vuex","slug":"vuex","link":"/tags/vuex/"}],"categories":[{"name":"python","slug":"python","link":"/categories/python/"},{"name":"django","slug":"django","link":"/categories/django/"},{"name":"closure","slug":"python/closure","link":"/categories/python/closure/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"lambda","slug":"python/lambda","link":"/categories/python/lambda/"},{"name":"restframework","slug":"django/restframework","link":"/categories/django/restframework/"},{"name":"middleware","slug":"django/middleware","link":"/categories/django/middleware/"},{"name":"UML","slug":"hexo/UML","link":"/categories/hexo/UML/"},{"name":"token","slug":"django/restframework/token","link":"/categories/django/restframework/token/"},{"name":"reflection","slug":"django/restframework/reflection","link":"/categories/django/restframework/reflection/"},{"name":"start","slug":"hexo/start","link":"/categories/hexo/start/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"hook","slug":"vue/hook","link":"/categories/vue/hook/"},{"name":"axios","slug":"vue/axios","link":"/categories/vue/axios/"},{"name":"templete","slug":"vue/templete","link":"/categories/vue/templete/"},{"name":"vuerouter","slug":"vue/vuerouter","link":"/categories/vue/vuerouter/"},{"name":"options","slug":"vue/options","link":"/categories/vue/options/"},{"name":"computed","slug":"vue/computed","link":"/categories/vue/computed/"},{"name":"vuex","slug":"vue/vuex","link":"/categories/vue/vuex/"}]}